(window.webpackJsonp=window.webpackJsonp||[]).push([["index"],{"3fe3":function(n,e){n.exports='# webpck与devserver的publicPath、path、contentBase\n\n### 项目目录\n\n```\ntest\n    |--assets\n        |--1.jpg\n    |--index.html\n    |--index.js\n    |--webpack.config.js\n    \n```\n### 1、使用webpack-dev-server构建打包出js，通过根目录下的index.html手动引入打包后的文件\n\n（1）文件内容如下：\n```\n\x3c!--index.html--\x3e\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <style>\n        .img {\n            width: 100px;\n        }\n    </style>\n</head>\n<body>\n    <div class="app">\n        <div class="test-1">test</div>\n        <div class="img-1">\n            <img class="img" src="" alt="">\n        </div>\n        <div class="img-2">\n            <img class="img" src="imgs/1.jpg" alt="">\n        </div>\n    </div>\n</body>\n<script src="/js/bundle.js"><\/script>\n</html>\n```\n\n```\n// index.js\nconsole.log(\'----index.js\')\nvar img = require(\'./assets/1.jpg\');\ndocument.querySelector(\'.img\').setAttribute(\'src\', img)\nconsole.log(\'----img\', img)\n```\n\n```\n// webpack.config.js\nconst path = require(\'path\');\n\nmodule.exports = {\n    entry: \'./index.js\',\n    output:{\n        filename: \'js/bundle.js\',\n        path: path.resolve(__dirname, \'dist\'),\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.(png|svg|jpg|jpeg|gif)$/,\n                // 使用url-loader, 它接受一个limit参数，单位byte；\n                // 当文件小于limit：将文件转为Data URI格式内联到引用的地方\n                // 当文件大于limit：将调用 file-loader, 把文件复制到输出目录，并将引用的文件路径改写成输出后的路径\n                use: [\n                    {\n                        loader: \'url-loader\',\n                        options: {\n                            limit: 20 * 1024,\n                            // 分离图片至imgs文件夹\n                            name: "imgs/[name].[ext]",\n                        }\n                    },\n                ]\n            },\n        ]\n    },\n}\n```\n\npackage.json中添加两条命令：\n```\n"scripts": {\n    "start": "webpack-dev-server --hot --progress --config webpack.config.js",\n    "build": "webpack --progress --config webpack.config.js"\n},\n```\n\n执行npm start：页面正常加载，html中可以正确加载图片和js。因为通过webpack-dev-server打包的文件默认会存放到内存中，访问路径就在根目录中；\n\n（2）修改（1）中的webpack.config.js\n\n```\n...\noutput:{\n    filename: \'js/bundle.js\',\n    path: path.resolve(__dirname, \'dist\'),\n    publicPath: \'dist\' // 添加这一行\n},\n...\n```\n执行npm start：页面正常加载，但是打开控制台发现html无法加载到载图片和js。因为通过webpack-dev-server打包的文件此时放到了内存中的/dist/目录下；\n\n修改index.html中js的引入路径即可成功加载，此时通过index.js引入的图片也被成功加载，并且图片引入路径变成了`<img class="img" src="/dist/imgs/1.jpg" alt="">`\n```\n<script src="/dist/js/bundle.js"><\/script>\n```\n\n结论：output.publicPath会改变webpack-dev-server打包文件存放的位置，同时会改变资源引入路径（增加前缀）\n\n（3）在（1）的基础上修改webpack.config.js\n\n```\ndevServer:{\n    publicPath: \'/dist/\'\n},\n```\n执行npm start：页面正常加载，但是打开控制台发现html无法加载到载图片和js。与（2）一样修改index.html中js的引入路径，可以成功加载到index.js，但是index.js中引入的图片无法成功加载，因为此时图片引入路径仍然为"imgs/1.jpg"，正确的引入路径应该是“/dist/imgs/1.jpg”\n\n结论：devServer.publicPath会改变webpack-dev-server打包文件存放的位置，但是不会改变资源引入路径；事实上，webpack-dev-server打包文件存放的位置会优先使用devServer.publicPath，找不到时再使用output.publicPath，都找不到就默认根目录\n\n（4）同时设置devServer和output的publicPath为\'/dist/\'，在这个案例里表现和（2）一致；\n\n\n### 2、使用html-webpack-plugin插件自动生成html（此html会自动引入打包后的资源）：\n\n（1）\n```\n\x3c!--index.html--\x3e\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <style>\n        .img {\n            width: 100px;\n        }\n    </style>\n</head>\n<body>\n    <div class="app">\n        <div class="test-1">test</div>\n        <div class="img-1">\n            <img class="img" src="" alt="">\n        </div>\n        <div class="img-2">\n            <img class="img" src="imgs/1.jpg" alt="">\n        </div>\n    </div>\n</body>\n</html>\n```\n\n```\n// webpack.config.js\nconst path = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n    entry: \'./index.js\',\n    output:{\n        filename: \'js/bundle.js\',\n        path: path.resolve(__dirname, \'dist\'),\n    },\n    devServer: {\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.(png|svg|jpg|jpeg|gif)$/,\n                // 使用url-loader, 它接受一个limit参数，单位byte；\n                // 当文件小于limit：将文件转为Data URI格式内联到引用的地方\n                // 当文件大于limit：将调用 file-loader, 把文件复制到输出目录，并将引用的文件路径改写成输出后的路径\n                use: [\n                    {\n                        loader: \'url-loader\',\n                        options: {\n                            limit: 20 * 1024,\n                            // 分离图片至imgs文件夹\n                            name: "imgs/[name].[ext]",\n                        }\n                    },\n                ]\n            },\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: path.resolve(__dirname, \'./index.html\'),\n        }),\n    ]\n}\n```\n\n其他文件保持和1初始化一致。\n\n执行npm start：页面正常加载，通过控制台查看此时的index.html，发现此时html-webpack-plugin帮我们引入的js路径是“js/bundle.js”，img的路径是“imgs/1.jpg”；此时webpack-dev-server打包生成的文件还是存放在根目录下；\n\n执行npm run build: 发现生成了dist文件夹，目录结果如下，并且生成的index.html加载js和js加载图片的路径都和npm start时一致\n```\ndist\n    |--imgs\n        |--1.jpg\n    |--js\n        |--bundle.js\n    |--index.html\n```\n\n结论：output.path会影响webpack打包生成的文件的存放位置，具体是：output.path + name/filename路径，比如output.filename使用了“js/”导致 生成的bundle.js会存放在/dist/js/下；同样如果在HtmlWebpackPlugin配置中添加filename，也会改变生成的index.html的位置(测试发现只有使用webpack打包时才有效，使用webpack-dev-server打包无效，即生产环境才能生效)\n\n```\nnew HtmlWebpackPlugin({\n    template: path.resolve(__dirname, \'./temp/index.html\'),\n    filename: \'../index.html\'\n}),\n```\n\n（2）修改（1）中的webpack.config.js\n```\n...\noutput:{\n    filename: \'js/bundle.js\',\n    path: path.resolve(__dirname, \'dist\'),\n    publicPath: \'/dist/\' // 添加这一行\n},\n...\n```\n\nnpm start：发现此时加载的页面没有加载js和图片，因为此时打包文件被放到了/dist/下，打开http://localhost:8080/dist/可以看到正常加载的页面，js和图片的引入路径都是\'/dist/\'开头;\n\nnpm build: 生成的index.html和npm start时打开http://localhost:8080/dist/看到的html一样，加载资源路径也一致，但是由于生成的html中直接使用/dist/js/bundle.js加载js，导致无法正确加载\n\n\n### 3、总结：\n\n（1）output.path：指示输出的目录，对应一个绝对路径。决定了打包后的资源（js/css/img等）的存放路径（前缀），通过修改output.filename或者loader的name可以继续修改路径；html-webpack-plugin只有在使用webpack打包时对filename添加路径才有效（比如\'../index.html\'），在devServer下是无效的，会导致找不到生成的html；\n\n（2）output.publicPath：会影响开发环境下devServer打包生成的文件的存放位置，以及开发和生成环境下资源引入路径（会给路径加前缀，前缀就是output.publicPath的值）；\n\n（3）devServer.publicPath：会影响开发环境下devServer打包生成的文件的存放位置，但是不会影响资源引入路径；devServer.publicPath优先级高于output.publicPath；\n\n（4）devServer.contentBase：通俗点来讲，它指定了本地实际存在的文件所在的目录（不是由devServer打包生成的文件，这些文件在内存中）；比如设置了contentBase: path.resolve(__dirname, \'./public\')，则\nhttp://localhost:8080会直接指向public文件夹，但是如果此时devServer打包生成的文件放在了默认的根目录下，http://localhost:8080仍然会指向devServer生成的文件，必须让devServer生成的文件指向别的地方才能使得http://localhost:8080接指向public文件夹，比如：\n\n```\noutput:{\n    filename: \'js/bundle.js\',\n    path: path.resolve(__dirname, \'./dist\'),\n    publicPath: "/dist/"\n},\ndevServer:{\n    publicPath: \'/dist/\',\n    contentBase: path.resolve(__dirname, \'./public\')\n},\n```\n\n此时devServer生成的文件都放在/dist下，可以通过http://localhost:8080/dist/访问；http://localhost:8080会直接定位到public文件夹下面的index.html.\n\n可以参考[配置DevServer](https://segmentfault.com/a/1190000013396072)\n\nps: devServer运行下所编译的文件都是存于内存中，不会改变本地文件；\n\n'},"5L5T":function(n,e){n.exports="# Node.js+Express+MongoDB 建站实例（1）-- 网站初始化\n\n> 项目地址：https://github.com/jiaoyanlin/myNodeProject\n\n> 作为一个前端小菜鸟，因为想学node，所以结合网上其他项目自己动手搭建做一个前后端完全分离的项目，模拟实际工作中前后端的工作配合。如有不足，请多指教。\n\n### 本项目为系列博客，目前有以下系列\n\n-  Node.js+Express+MongoDB 建站实例（1）-- 网站初始化\n-  [Node.js+Express+MongoDB 建站实例（2）-- 登录模块]\n-  [Node.js+Express+MongoDB 建站实例（3）-- 上传图片及其他模块]\n-  Node.js+Express+MongoDB 建站实例（4）-- react构建前端页面对接接口：[项目源码](https://github.com/jiaoyanlin/react-background-system)\n\n\n### 一、源码运行\n\n可到GitHub上下载源项目，然后执行以下步骤搭建我已经写好的项目进行体验。从本文第二步开始为大家讲解整个项目的详细实现步骤。\n   \n```javascript\n\nnpm install\n\nnpm start 或 supervisor bin/www（必须提前安装supervisor）\n\n```\n备注：本项目建立在本地已经搭建好了nodejs和mongodb的基础上（搭建方法请自行百度）。\n\n### 二、以下用来记录项目从头开始搭建的流程\n\n#### 初始化项目\n\n1. 安装Express\n\n    `npm install -g express`\n    \n2. 安装Express命令行工具\n\n    `npm install -g express-generator`\n    \n3. 使用express初始化项目：这里使用ejs模板，默认为jade模板\n\n    `express -e myproject`\n\n    提示：此时将在当前目录下创建myproject子目录，并自动搭建其他相关目录及文件。\n    \n    `cd myproject` 进入项目目录\n    \n    `npm install` 安装相关依赖\n    \n4. 运行项目\n    \n    `SET DEBUG=myproject:* & npm start`\n\n    此时在浏览器上输入http:localhost:3000将能看到相关页面\n    \n5. 若不想每次修改代码后都要重启服务器，可以安装并使用supervisor工具实现代码修改和自启动\n\n    `npm install -g supervisor`\n    \n    `supervisor bin/www` \n    \n    提示：express 4.x把原来用于项目启动代码也被移到./bin/www的文件，所以直接运行 supervisor bin/www就可以了（更早版本使用 `supervisor  app.js`）\n\n#### 实战热身（实现基础的get和post的ajax请求）\n\n1. 安装mongodb模块（须先在电脑上安装过mongodb并且启动服务）\n\n    `npm install mongodb --save`\n    \n    ps: \"crypto\": \"^1.0.1\",未确定是否需要安装？？？？？\n    \n2. 修改/routes/index.js，新增两个接口\n\n    ```javascript\n    var express = require('express');\n    var router = express.Router();\n    \n    // 我新增的api，用于连接到数据库\n    var api = require('./api.js')\n    \n    /* GET home page. */\n    router.get('/', function(req, res, next) {\n      res.render('index', { title: 'Express' });\n    });\n    \n    // 我新增的测试接口\n    router.get('/api/test', api.test)\n    \n    router.post('/api/addtest', api.addtest)\n    \n    module.exports = router;\n    \n    ```\n    \n3. 新增文件1 /routes/api.js\n\n    ```javascript\n    const db = require('./db.js')\n    \n    exports.test = function(req, res, next) {\n      db.find('mytest', { \"query\": {} }, function(err, result) {\n        if (err) {\n          return res.json({\n            \"code\": 404,\n            \"message\": \"数据查询失败\",\n            \"result\": []\n          })\n        }\n        return res.json({\n            \"code\": 200,\n            \"message\": \"数据获取成功\",\n            \"result\": result,\n            \"total\": result.length\n        })\n      })\n    }\n    \n    exports.addtest = function(req, res, next) {\n      let newData = {\n        \"title\": req.body.title,\n        \"content\": req.body.content\n      };\n      // 插入到数据库\n      db.insertOne('mytest', newData, function(err, result) {\n        if (err) {\n          return res.json({\n            \"code\": 401,\n            \"message\": \"test新增失败\"\n          })\n        }\n        return res.json({\n          \"code\": 200,\n          \"message\": \"test新增成功\"\n        })\n      })\n    }\n    ```\n    新增文件2 /routes/db.js（封装了对数据库的增删查改的函数）\n    ```javascript\n    const MongoClient = require('mongodb').MongoClient\n    const settings = require('./settings')\n    // 链接数据库 如果没有自动创建\n    function _connectDB(callback) {\n      let url = settings.dbUrl\n      MongoClient.connect(url, function(err, db) {\n        if (err) {\n          callback(err, null)\n          return\n        }\n        // 数据库链接成功执行回掉\n        callback(err, db)\n      })\n    }\n    \n    // 插入数据\n    exports.insertOne = function(collectionName, json, callback) {\n      _connectDB(function(err, db) {\n        db.collection(collectionName).insertOne(json, function(err, result) {\n          if (err) {\n            callback(err, null)\n            db.close()\n            return\n          }\n          callback(err, result)\n          db.close()\n        })\n      })\n    }\n    \n    // 查找数据\n    exports.find = function(collectionName, queryJson, callback) {\n      _connectDB(function(err, db) {\n        let json = queryJson.query || {},\n          limit = Number(queryJson.limit) || 0,\n          count = Number(queryJson.page) - 1,\n          sort = queryJson.sort || {}\n        // 页数为0或者1都显示前limit条数据\n        if (count <= 0) {\n          count = 0\n        } else {\n          count = count * limit\n        }\n    \n        let cursor = db.collection(collectionName).find(json).limit(limit).skip(count).sort(sort)\n        cursor.toArray(function(err, results) {\n          if (err) {\n            callback(err, null)\n            db.close()\n            return\n          }\n          callback(err, results)\n          db.close()\n        })\n      })\n    }\n    \n    // 删除数据\n    exports.deleteMany = function(collectionName, json, callback) {\n      _connectDB(function(err, db) {\n        db.collection(collectionName).deleteMany(json, function(err, results) {\n          if (err) {\n            callback(err, null)\n            db.close()\n            return\n          }\n          callback(err, results)\n          db.close()\n        })\n      })\n    }\n    \n    // 修改数据\n    exports.updateMany = function(collectionName, jsonOld, jsonNew, callback) {\n      _connectDB(function(err, db) {\n        db.collection(collectionName).updateMany(\n          jsonOld, {\n            $set: jsonNew,\n            $currentDate: { \"lastModified\": false }\n          },\n          function(err, results) {\n            if (err) {\n              callback(err, null)\n              db.close()\n              return\n            }\n            callback(err, results)\n            db.close()\n          })\n      })\n    }\n    ```\n    新增文件3 /routes/settings.js（mongodb数据库相关设置）\n    ```javascript\n    let nickname = 'myproject1'\n    module.exports = {\n        dbUrl:'mongodb://localhost:27017/myproject1',\n        nickname:nickname\n    }\n    ```\n    到此，接口创建完毕\n    \n4. 前端使用ajax来获取数据\n\n    /views/index.ejs\n    ```html\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title><%= title %></title>\n        <link rel='stylesheet' href='/stylesheets/style.css' />\n        <script src='/js/jquery.min.js'><\/script>\n      </head>\n      <body>\n        <h1><%= title %></h1>\n        <p>Welcome to <%= title %></p>\n        <div class=\"post\">\n          <input type=\"text\" class=\"title\" placeholder=\"请输入标题\">\n          <input type=\"text\" class=\"content\" placeholder=\"请输入标题\">\n          <button class=\"ok\">提交</button>\n        </div>\n        <div class=\"test\"></div>\n      </body>\n      <script>\n        function getList() {\n          $.get('/api/test', {}, function (data) {\n            console.log('----data', data)\n            if (data.code == 200) {\n              var html = '', list = data.result;\n              for (var i = 0; i < list.length; i++) {\n                html += '<div>这是第' + i + '条数据：标题为' + list[i].title + '，内容为' + list[i].content + '</div>'\n              }\n              $('.test').empty().append(html);\n            }\n          })\n        }\n        getList();\n        $('.ok').click(function() {\n          if (!$('.title').val()) {\n            alert('请填写标题');\n            return false;\n          }\n          if (!$('.content').val()) {\n            alert('请填写内容');\n            return false;\n          }\n          $.post('/api/addtest', {\n            title: $('.title').val(),\n            content: $('.content').val()\n          }, function (data) {\n            console.log('----addtest', data)\n            if (data.code == 200) {\n              alert('提交成功');\n              getList();\n            } else {\n              alert('提交失败');\n            }\n          })\n        })\n      <\/script>\n    </html>\n    ```\n    打开浏览器控制台，可以看到打印出查到的数据。\n    \n    \n### 补充说明\n文章只是分享我的一些学习历程，如果有错误，求轻拍，我一定虚心受教。我从事前端行业不久，很多东西理解还有偏差，不足之处，请多见谅，很多东西没写详细，后期有时间会再补上。此外这个项目后面我想继续完善下去，当前只是写个小demo试一下而已，请继续关注，如果可以的话可以到我GitHub上面给个星鼓励下哦。\n    \n    \n### 参考文档\n1、http://y.dobit.top/Detail/150.html\n\n2、https://github.com/wmui/vueblog\n"},FIf5:function(n,e,t){n.exports=t("qDsG")(10)},JG2H:function(n,e){n.exports=_dll_vendor},Kw5r:function(n,e,t){n.exports=t("JG2H")(2)},L2JU:function(n,e,t){n.exports=t("JG2H")(7)},Ldmx:function(n,e,t){},Lgyv:function(n,e){n.exports='# babel7使用笔记\n\n### 以下笔记都是下面几篇文章中摘抄的：\n\n* [你真的会用 Babel 吗?](https://juejin.im/post/59b9ffa8f265da06710d8e89)\n* [Show me the code，babel 7 最佳实践](https://juejin.im/post/5c03a4d0f265da615e053612)\n* [Babel学习系列4-polyfill和runtime差别(必看)](https://zhuanlan.zhihu.com/p/58624930)\n\n\n#### 几点说明\n\n* Babel 把 Javascript 语法 分为 syntax 和 api；api 指那些我们可以通过 函数重新覆盖的语法 ，类似 includes,map,includes,Promise（可以通过重写进行覆盖）；syntax是像 箭头函数、let、const、class等；\n*  Babel 只转换 syntax，不转换 syntax；但是babel提供了 polyfill 这个模块用来处理syntax，polyfill会重写浏览器不兼容的那些syntax用法（比如assign等）；\n* 但是polyfill包很大，因此需要使用@babel/preset-env 的 useBuiltIns 来按需引入；\n* 如果使用polyfill，那么很多方法都被重写了，如果用在第三方组件库的开发就很不合适，会导致使用这个库的用户无法预知哪些方法已经被重写；因此babel提供了`@babel/runtime 和 @babel/plugin-transform-runtime`用来提供不会重写全局方法又能兼容低版本环境的方法；\n\n> 总结：Babel 只是转换 syntax 层语法,所以需要 @babel/polyfill 来处理API兼容,又因为 polyfill 体积太大，所以通过 preset 的 useBuiltIns 来实现按需加载,再接着为了满足 npm 组件开发的需要出现了 @babel/runtime 来做隔离\n\n\n#### 一、项目中使用babel并按需引入polyfill\n\n```\nnpm i -S @babel/polyfill @babel/runtime\nnpm i -D @babel/preset-env @babel/plugin-transform-runtime\n```\n\n1、@babel/preset-env 按需加载\n```\n// .babelrc.js\nmodule.exports = {\n    presets: [\n        [\n            "@babel/preset-env",\n            \n            {\n                "modules": false, // 模块使用 es modules ，不使用 commonJS 规范\n                "useBuiltIns": \'usage\', // 默认 false, 可选 entry , usage\n            }\n        ]\n    ]\n}\n```\n\nuseBuiltIns 选项：\n\n* false : 不启用polyfill\n* entry : 启用，需要手动 import \'@babel/polyfill\' 才生效\n* usage : 不需要手动import \'@babel/polyfill\'(加上也无妨，编译时会自动去掉), 且会根据 .browserslist + 业务代码使用到的新 API 按需进行 polyfill\n\n如果需要启用polyfill，记得先手动安装`npm i -S @babel/polyfill`；但是使用“usage”配置后，每个文件都会内联一遍helpers 代码，导致代码重复，使用@babel/plugin-transform-runtime优化\n\n\n2、@babel/plugin-transform-runtime\n\n*  helpers 选项就可以把这些重复的模块抽离出来\n\n```javascript\n// .babelrc.js\nmodule.exports = {\n    presets: [\n        [\n            "@babel/preset-env",\n            \n            {\n                "modules": false, // 模块使用 es modules ，不使用 commonJS 规范 \n                "useBuiltIns": \'usage\', // 默认 false, 可选 entry , usage\n            }\n        ]\n    ],\n    "plugins": [\n        [\n            "@babel/plugin-transform-runtime",\n            {\n                "corejs": false, // 默认值，可以不写\n                "helpers": true, // 默认，可以不写\n                "regenerator": false, // 通过 preset-env 已经使用了全局的 regeneratorRuntime, 不再需要 transform-runtime 提供的 不污染全局的 regeneratorRuntime\n                "useESModules": true, // 使用 es modules helpers, 减少 commonJS 语法代码\n            }\n        ]\n    ],\n}\n```\n\n#### 二、第三方库中使用babel\n\n```\nnpm install --save @babel/runtime\nnpm install --save-dev @babel/plugin-transform-runtime\nnpm install --save @babel/runtime-corejs2 --save  // 官方文档说这个可以不加\n```\n\n```javascript\n// .babelrc.js\n{\n    "presets": [\n        [\n            "@babel/preset-env",\n            {\n                "useBuiltIns": false, // 是否开启自动支持 polyfill\n                "modules": false, // 模块使用 es modules ，不使用 commonJS 规范\n                "targets": {\n                    "browsers": ["> 1%", "last 2 versions", "not ie <= 8"]\n                }\n            }\n        ]\n    ],\n    "plugins": [\n        [\n            "@babel/plugin-transform-runtime",\n            {\n                // useESModules：引入的helpers是否是es modules规范的；注意当打包成cjs时要设置成false，否则会报错\n                // "useESModules": true,\n                "corejs": 2 // 参考官方文档\n            }\n        ]\n    ],\n}\n```\n\n\n> 关于 @babel/preset-env 中 targets 的设置请参考： [“last 2 versions” 之遗祸](http://jimyuan.github.io/blog/2018/04/26/last-2-versions-considered-harmful.html)\n'},Mb3Q:function(n,e,t){n.exports=t("JG2H")(8)},"O60+":function(n,e,t){n.exports=t.p+"imgs/head.jpg"},PAZ5:function(n,e){n.exports="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAAQABADAREAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABgUH/8QAKBAAAQIGAQMDBQAAAAAAAAAAAQIDBAUGBxESCAATIRQXMSIkMjNx/8QAGQEAAQUAAAAAAAAAAAAAAAAABAMFBgcI/8QAKBEAAQIFAwQBBQAAAAAAAAAAAQIRAwQGEiEABTETFBVBYRZRkbHx/9oADAMBAAIRAxEAPwAxYzi1IavtpM78XlrV6k7fyxxTSXIRnuxkcpKw2e3kEJHcUEA6qJUCMADPVeyW2IiwDNzKrYY/J1saqa6mNu3SHT+yQBGm15yWSnD54fGTkMMv61FuajhsaMj02lduYKoZU0IJU69L6N4dxIcK+2Nv17kY1+rH86SmfG9M9vdd6dm0dshrXvkeYEv0C91l9wwWZ8cs/OH03svyctb7DRPGm/lOTp6mi6tyAmckKC/D7PmIwpKiPKXSpQUNshWpRgZJUnuUDtDJTaTb6I55f9/zTFUtEbt9QJqinoqBHYBSIjsWTbgj7pYEYZnCn1l135Xxmlsmg/ZKpq3m81XF/dGdsMtQ7cNor8dEJUV7a+fjAPj46Bm0ySUjtVKJ+W41K6dj1RGjq87ChIhtjplRUVOOXJDM/wAu2v/Z"},Ryk6:function(n,e,t){var s={"./01node/01.md":"5L5T","./01node/02.md":"kKVl","./01node/03.md":"tjWA","./02webpack/01.md":"lg5E","./02webpack/02.md":"Lgyv","./02webpack/03.md":"ddCq","./02webpack/04.md":"3fe3","./04react/01.md":"n9MT","./04react/02.md":"SGWl","./04react/03.md":"gAYf","./04react/04.md":"mxS1","./06rollup/01.md":"X7Un"};function o(n){var e=i(n);return t(e)}function i(n){if(t.o(s,n))return s[n];var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}o.keys=function(){return Object.keys(s)},o.resolve=i,(n.exports=o).id="Ryk6"},SGWl:function(n,e){n.exports="# React-Native开发：react-native-image-crop-picker图片上传组件的使用（安卓）\n\n1、根据[官网](https://github.com/ivpusic/react-native-image-crop-picker#android)提供的步骤进行相应的设置\n\n（1）`npm i react-native-image-crop-picker --save`\n\n（2）`react-native link react-native-image-crop-picker`这里命令窗很不幸地始终没什么动静（除了几行字）\n\n（3）Make sure you are using Gradle 2.2.x (android/build.gradle)：\n\n```\nbuildscript {\n    ...\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.2.3'\n        ...\n    }\n    ...\n}\n```\n\n（4）VERY IMPORTANT Add the following to your build.gradle's repositories section. (android/build.gradle)：\n```\nallprojects {\n    repositories {\n      mavenLocal()\n      jcenter()\n      maven { url \"$rootDir/../node_modules/react-native/android\" }\n\n      // jitpack repo is necessary to fetch ucrop dependency\n      maven { url \"https://jitpack.io\" }\n    }\n}\n```\n\n（5）Add useSupportLibrary (android/app/build.gradle):\n\n```\nandroid {\n    ...\n\n    defaultConfig {\n        ...\n        vectorDrawables.useSupportLibrary = true\n        ...\n    }\n    ...\n}\n```\n\n（6）可选：app\\src\\main\\AndroidManifest.xml\n\n```\n<uses-permission android:name=\"android.permission.CAMERA\"/>\n```\n\n2、开始运行：\n\n配置完上述内容后我用Android Studio重新build了一遍项目，但是报错了：\n程序包com.reactnative.ivpusic.imagepicker不存在 找不到符号等等\n\n搜索一番后得到一个方案：https://github.com/ivpusic/react-native-image-crop-picker/blob/79d3dab7e5dd377551701a74203deb5667bdfde2/README.md#android-1\n\n然鹅还是有问题，运行起来还是有问题，应该是链接原生库没成功（`react-native link react-native-image-crop-picker`）。最终经过多次尝试后，我修改了以下文件的以下地方：\n\n（1）file: android/app/build.gradle：\n\n```\ndependencies {\n    ...\n    compile project(':react-native-image-crop-picker')\n}\n```\n\n（2）file: MainApplication.java\n\n```\n...\n\nimport com.reactnative.ivpusic.imagepicker.PickerPackage; // import package\n\npublic class MainApplication extends ReactApplication {\n...\n   /**\n   * A list of packages used by the app. If the app uses additional views\n   * or modules besides the default ones, add more packages here.\n   */\n    @Override\n    protected List<ReactPackage> getPackages() {\n        return Arrays.<ReactPackage>asList(\n            new MainReactPackage(),\n            new PickerPackage() // Add package\n        );\n    }\n...\n}\n```\n\n（3）file: android/settings.gradle:\n\n```\ninclude ':react-native-image-crop-picker'\nproject(':react-native-image-crop-picker').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-image-crop-picker/android')\n```\n\n（4）此时再用Android Studio重新build了一遍项目即可成功使用react-native-image-crop-picker了，是在不行将node_modules删除，重新安装依赖，再多build几遍项目试试。该插件具体使用可以参考https://blog.csdn.net/u013718120/article/details/72781285。\n"},"T+MD":function(n,e,t){var s={"./01node/01.md":"5L5T","./01node/02.md":"kKVl","./01node/03.md":"tjWA","./02webpack/01.md":"lg5E","./02webpack/02.md":"Lgyv","./02webpack/03.md":"ddCq","./02webpack/04.md":"3fe3","./04react/01.md":"n9MT","./04react/02.md":"SGWl","./04react/03.md":"gAYf","./04react/04.md":"mxS1","./06rollup/01.md":"X7Un"};function o(n){var e=i(n);return t(e)}function i(n){if(t.o(s,n))return s[n];var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}o.keys=function(){return Object.keys(s)},o.resolve=i,(n.exports=o).id="T+MD"},X7Un:function(n,e){n.exports="# rollup开发依赖包（npm library）实战\n\n> 本文涉及包版本：node 11.6.0 、npm 6.11.3、webpack 4.39.3；使用mac开发；\n\n## 项目\n\n[源码](https://github.com/jiaoyanlin/npm-library-demo) -> https://github.com/jiaoyanlin/npm-library-demo ，求star😄\n\n```\nnpm i\nnpm start\n```\n\n建议开始动手实践前先浏览下本文的的 三、知识点\n\n## 一、发布包基本流程\n\n#### 1、使用nrm管理npm源：\n\n> nrm：npm registry 管理工具，方便切换不同的源；我们开发的包要发布的源是https://registry.npmjs.org，更详细的安装可以参考[nrm —— 快速切换 NPM 源](https://segmentfault.com/a/1190000000473869)\n\n```\n// 安装\nnpm install -g nrm\n// 查看\nnrm ls\n// 切换\nnrm use taobao\n// 增加源\nnrm add  <registry> <url> [home]\n// 删除源\nnrm del <registry>\n```\n\n#### 2、发布包：\n\n> 记得先在 https://www.npmjs.com 注册账户并在邮箱激活账户\n\n（1）编写包代码(npm init等操作，具体在下面会提及)\n\n（2）切换registry到npm对应链接https://registry.npmjs.org/：nrm use npm\n\n（3）登录：npm login\n\n（4）发布、更新：npm publish\n\n#### 3、关于为何选择rollup而不是webpack编写一个npm包\n\n> 为了支持tree shaking，得导出一份符合es6模块规范的代码，但是webpack不支持导出为es6模块，所以使用rollup来开发我们的包\n\n> [rollup和webpack使用场景分析](https://www.jianshu.com/p/60070a6d7631)中提到：Rollup偏向应用于js库，webpack偏向应用于前端工程，UI库；如果你的应用场景中只是js代码，希望做ES转换，模块解析，可以使用Rollup。如果你的场景中涉及到css、html，涉及到复杂的代码拆分合并，建议使用webpack。\n\n> rollup可以直接构建出符合es6模块规范的代码（有利于tree shaking），但是webpack不能；因此为了更好地使用es6模块化来实现tree shaking，以及优化包代码体积等原因，选用rollup来开发npm包；\n\n## 二、使用rollup构建npm包\n\n> 以下内容引自[rollup中文网](https://www.rollupjs.com/guide/introduction/): 为了确保你的 ES6 模块可以直接与「运行在 CommonJS（例如 Node.js 和 webpack）中的工具(tool)」使用，你可以使用 Rollup 编译为 UMD 或 CommonJS 格式，然后在 package.json 文件的 main 属性中指向当前编译的版本。如果你的 package.json 也具有 module 字段，像 Rollup 和 webpack 2 这样的 ES6 感知工具(ES6-aware tools)将会直接导入 ES6 模块版本。\n\n> 关于rollup更加详细的介绍及使用，可以参考以下文章：[Rollup：下一代ES模块打包工具](https://zhuanlan.zhihu.com/p/75717476) 、[rollup中文网](https://www.rollupjs.com/guide/introduction/) 、[Rollup.js 实战学习笔记](https://rollupjs.org/guide/zh/)、[webpack创建library](https://chenshenhai.github.io/rollupjs-note/)\n\n\n#### 1、先来个简单的demo：[源码](https://github.com/jiaoyanlin/npm-library-demo/tree/master/demos/demo-1)\n\n（1）新建一个文件夹npm-library-demo\n\n初始化：\n```\ncd npm-library-demo\nnpm init -y // 初始化，生成package.json\nnpm i rollup -D // 安装rollup\n```\n\n根据以下目录结构新增文件夹及文件：\n```\nnpm-library-demo\n    |--build\n        |--rollup.config.js\n    |--example\n        |--index.html\n    |--src\n        |--main.js\n        |--foo.js\n```\n\n（2）文件内容：\n\npackage.json中加入构建脚本命令：\n```\n\"scripts\": {\n    \"build\": \"rollup -c ./build/rollup.config.js\"\n}\n```\n\n```javascript\n// rollup.config.js\nconst path = require('path');\nconst resolve = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\nexport default {\n    input: resolve('src/main.js'), // 入口文件\n    output: { // 出口文件\n        file: resolve('dist/bundle.js'),\n        format: 'umd',\n        name: 'myLibrary'\n    }\n};\n```\n\n```javascript\n// main.js\nimport foo from './foo.js';\nexport default (function () {\n\tconsole.log(foo);\n})();\n```\n\n```javascript\n// foo.js\nexport default 'hello world!';\n```\n\nindex.html:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>example</title>\n</head>\n<body>\n    \n</body>\n<script src=\"../dist/bundle.js\"><\/script>\n</html>\n```\n\n（3）执行`npm run build`，就可以生成打包文件/dist/bundle.js，打开example/index.html控制台可以查看打包文件是否生效\n\n#### 2、使用插件，在1的基础上进行以下操作：[源码](https://github.com/jiaoyanlin/npm-library-demo/tree/master/demos/demo-2)\n\n在rollup中如果要处理json，就要用到插件，比如rollup-plugin-json\n\n`npm i rollup-plugin-json -D`\n\n```javascript\n// rollup.config.js\nconst path = require('path');\nimport json from 'rollup-plugin-json';\n\nconst resolve = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\n\nexport default {\n    input: resolve('src/main.js'),\n    output: {\n        file: resolve('dist/bundle.js'),\n        format: 'umd',\n        name: 'myLibrary'\n    },\n    plugins: [ // 在此处使用插件\n        json(),\n    ],\n};\n\n```\n\n```javascript\n// main.js\nimport foo from './foo.js';\nimport { version } from '../package.json'; // 利用json插件可以获得package.json中的数据\nconsole.log('version ' + version);\nexport default (function () {\n\tconsole.log(foo);\n})();\n```\n\n此时再次使用`npm run build`打包，打开index.html，在控制台可以看到相关结果\n\n其他插件使用方式类似\n\n#### 3、Rollup 与其他工具集成\n\n##### （1）npm packages：添加配置让rollup知道如何处理你从npm安装到node_modules文件夹中的软件包\n\n`npm install rollup-plugin-node-resolve rollup-plugin-commonjs -D`\n\n* rollup-plugin-node-resolve: 告诉 Rollup 如何查找外部模块\n* rollup-plugin-commonjs：将CommonJS模块转换为 ES2015 供 Rollup 处理，请注意，rollup-plugin-commonjs应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测\n\n\n```javascript\n// rollup.config.js\nimport resolve from 'rollup-plugin-node-resolve';\nimport commonjs from 'rollup-plugin-commonjs';\n\nimport json from 'rollup-plugin-json';\n\nconst path = require('path');\nconst resolveFile = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\n\nexport default {\n    input: resolveFile('src/main.js'),\n    output: {\n        file: resolveFile('dist/bundle.js'),\n        format: 'cjs',\n    },\n    plugins: [\n        commonjs(),\n        resolve({\n            // 将自定义选项传递给解析插件\n            customResolveOptions: {\n                moduleDirectory: 'node_modules'\n            }\n        }),\n        json(),\n    ],\n};\n```\n\n##### （2）external：有些包要处理成外部引用（例如lodash等），externals就是用来处理外部的引用，不要将这些包打包到输出文件中，减小打包文件体积\n\n> external 接受一个模块名称的数组或一个接受模块名称的函数，如果它被视为外部引用（externals）则返回true\n\n```javascript\n// rollup.config.js\nexport default {\n    ...,\n    // 作用：指出应将哪些模块视为外部模块，否则会被打包进最终的代码里\n    external: ['lodash']\n    // external: id => /lodash/.test(id) // 也可以使用这种方式\n};\n```\n\n安装lodash：`npm i lodash -S`\n```javascript\n// main.js\n...\nimport _ from 'lodash';\nconsole.log('-------lodash:', _.defaults({ 'a': 1 }, { 'a': 3, 'b': 2 }));\n```\n可以打包试试external配置与否对打包文件的影响（直接查看dist/bundle.js）\n\n由于此时打包生成的是cjs格式的js，可以直接在控制台执行`node ./dist/bundle.js`测试打包结果；此时index.html是没法成功加载bundle.js的，因为此时的文件是cjs的，无法直接在浏览器中使用\n\n##### （3）babel7：\n\n`npm i -D rollup-plugin-babel @babel/core @babel/plugin-transform-runtime @babel/preset-env`\n\n`npm i -S @babel/runtime @babel/runtime-corejs2`\n\n```javascript\n// rollup.config.js\n...\nimport babel from 'rollup-plugin-babel';\n\nexport default {\n    ...\n    plugins: [\n        ...,\n        babel({\n            exclude: 'node_modules/**', // 只编译我们的源代码\n            runtimeHelpers: true,\n        }),\n    ],\n    external: id => {\n        return /@babel\\/runtime/.test(id) || /lodash/.test(id);\n    }\n}\n```\n根目录下新建文件.babelrc.js\n```javascript\nmodule.exports = {\n    presets: [\n        [\n            \"@babel/preset-env\",\n            {\n                // \"debug\": true, // debug，编译的时候 console\n                \"useBuiltIns\": false, // 是否开启自动支持 polyfill\n                \"modules\": false, // 模块使用 es modules ，不使用 commonJS 规范\n                // \"targets\": \"> 0.25%, last 2 versions, iOS >= 8, Android >= 4.4, not dead\"\n            }\n        ]\n    ],\n    plugins: [\n        [\n            \"@babel/plugin-transform-runtime\",\n            {\n                // useESModules：引入的helpers是否是es modules规范的；注意当打包成cjs时不能引入es modules下的代码，会报错\n                // \"useESModules\": true,\n                \"corejs\": 2 // 参考官方文档\n            }\n        ],\n    ]\n}\n```\n可以自己在main.js中加入一些es6语法，看看打包后的文件是否将es6语法编译成了es5（如const、let等）\n\n??????? babel还有一篇相关博文补充\n\n##### （4）引入eslint：\n\n`npm i -D babel-eslint rollup-plugin-eslint`\n\n> eslint位置很重要，放在babel插件后面会导致定位问题的时候出错\n\n```javascript\n// rollup.config.js\n...\nimport { eslint } from 'rollup-plugin-eslint';\n\nmodule.exports = {\n    ...,\n    plugins: [\n        ...,\n        eslint({ // eslint插件必须放在babel插件之前，不然检测的是转换后的文件，导致检测有误\n            throwOnError: true,\n            throwOnWarning: true,\n            include: ['src/**'],\n            exclude: ['node_modules/**']\n        }),\n        ...\n    ]\n}\n```\n\n根目录下新增文件.eslitrc.js\n```javascript\nmodule.exports = {\n    //一旦配置了root，ESlint停止在父级目录中查找配置文件\n    root: true,\n    parser: \"babel-eslint\", // 配置babel-eslint，避免在使用es6类属性时，eslint报Parsing error: Unexpected token\n    //想要支持的JS语言选项\n    parserOptions: {\n        //启用ES6语法支持(如果支持es6的全局变量{env: {es6: true}}，则默认启用ES6语法支持)\n        //此处也可以使用年份命名的版本号：2015\n        ecmaVersion: 6,\n        //默认为script\n        sourceType: \"module\",\n        //支持其他的语言特性\n        ecmaFeatures: {}\n    },\n    //代码运行的环境，每个环境都会有一套预定义的全局对象，不同环境可以组合使用\n    env: {\n        amd: true, // 否则会出现'require' is not defined 提示\n        es6: true,\n        browser: true,\n        jquery: true\n    },\n    //访问当前源文件中未定义的变量时，no-undef会报警告。\n    //如果这些全局变量是合规的，可以在globals中配置，避免这些全局变量发出警告\n    globals: {\n        //配置给全局变量的布尔值，是用来控制该全局变量是否允许被重写\n        test_param: true,\n        window: true,\n        process: false,\n    },\n    //集成推荐的规则\n    extends: [\"eslint:recommended\"],\n    //启用额外的规则或者覆盖默认的规则\n    //规则级别分别：为\"off\"(0)关闭、\"warn\"(1)警告、\"error\"(2)错误--error触发时，程序退出\n    rules: {\n        //关闭“禁用console”规则\n        \"no-console\": \"off\",\n        //缩进不规范警告，要求缩进为2个空格，默认值为4个空格\n        \"indent\": [\"warn\", 4, {\n            //设置为1时强制switch语句中case的缩进为2个空格\n            \"SwitchCase\": 1,\n        }],\n        // 函数定义时括号前面要不要有空格\n        \"space-before-function-paren\": [0, \"always\"],\n        //定义字符串不规范错误，要求字符串使用双引号\n        // quotes: [\"error\", \"double\"],\n        //....\n        //更多规则可查看http://eslint.cn/docs/rules/\n    }\n}\n```\n##### （5）一次编译，同时打包生成不同格式文件，如cjs、es、umd等\n\n有两种方法：\n\n首先，`npm i -D rollup-plugin-serve rollup-plugin-uglify`\n\n修改packag.json\n```json\n{\n    ...,\n    \"module\": \"es/index.js\",\n    \"main\": \"lib/index.js\",\n    \"scripts\": {\n        \"build\": \"rollup -c ./build/rollup.config.js\"\n        \"clean\": \"rm -rf ./dist/ ./es/ ./lib/\",\n        \"easy\": \"npm run clean && NODE_ENV=development rollup -w -c ./build/easy.config.js\",\n        \"node:dev\": \"npm run clean && NODE_ENV=development node ./build/dev.js\",\n        \"node:build\": \"npm run clean && NODE_ENV=production node ./build/build.js\",\n        \"start\": \"npm run clean && NODE_ENV=development rollup -w -c ./build/rollup.config.js\",\n        \"build\": \"npm run clean && NODE_ENV=production rollup -c ./build/rollup.config.js\"\n   },\n   \"files\": [\n        \"dist\",\n        \"lib\",\n        \"es\",\n        \"types\"\n  ],\n\n```\n\n注意：mac可以直接使用NODE_ENV=development方式传递变量，window下不一定可以，如果失败请引入[cross-env](https://juejin.im/post/5c009b13f265da612e285d43)\n\n（1）第一种方法：使用rollup命令打包\n\n```javascript\n// rollup.config.js\nimport json from 'rollup-plugin-json';\nimport resolve from 'rollup-plugin-node-resolve';\nimport commonjs from 'rollup-plugin-commonjs';\nimport babelPlugin from 'rollup-plugin-babel';\nimport serve from 'rollup-plugin-serve';\nimport { uglify } from 'rollup-plugin-uglify';\nimport { eslint } from 'rollup-plugin-eslint'\n\nconst path = require('path');\nconst resolveFile = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\nconst isDev = process.env.NODE_ENV !== 'production';\nconsole.log('----------dev:', process.env.NODE_ENV, isDev)\n\n// 通过控制outputs中对应的isExternal、isUglify值来决定打包的文件是否启用external和uglify\nconst outputs = [\n    {\n        file: resolveFile('lib/index.js'),\n        format: 'cjs',\n        isExternal: true,\n    },\n    {\n        file: resolveFile('es/index.js'),\n        format: 'es',\n        isExternal: true,\n    },\n    {\n        file: resolveFile('dist/index.js'),\n        format: 'umd',\n        name: 'npmLibraryDemo',\n    },\n    {\n        file: resolveFile('dist/index.min.js'),\n        format: 'umd',\n        name: 'npmLibraryDemo',\n        isUglify: true,\n    }\n].map(i => {\n    i.sourcemap = isDev; // 开发模式：开启sourcemap文件的生成\n    return i;\n});\nconst len = outputs.length;\n\nconst config = outputs.map((output, i) => {\n    const isUglify = output.isUglify || false;\n    const isExternal = output.isExternal || false;\n    console.log('------config:', isExternal)\n    return {\n        input: resolveFile('src/main.js'),\n        output,\n        plugins: [\n            // rollup-plugin-commonjs应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测\n            // 作用：将CommonJS模块转换为 ES2015 供 Rollup 处理\n            commonjs(),\n            // 作用：处理json格式文件\n            json(),\n            // 作用：告诉 Rollup 如何查找外部模块\n            resolve({\n                // 将自定义选项传递给解析插件\n                customResolveOptions: {\n                    moduleDirectory: 'node_modules'\n                }\n            }),\n            eslint({\n                throwOnError: true,\n                throwOnWarning: true,\n                include: ['src/**'],\n                exclude: ['node_modules/**']\n            }),\n            babelPlugin({\n                exclude: 'node_modules/**', // 只编译我们的源代码\n                runtimeHelpers: true,\n            }),\n            ...(\n                isDev && i === len - 1 ?\n                    [\n                        serve({ // 使用开发服务插件\n                            port: 3001,\n                            // 设置 exmaple的访问目录和dist的访问目录\n                            contentBase: [resolveFile('example'), resolveFile('dist')]\n                        })\n                    ] : isUglify ? [\n                        uglify()\n                    ] : []\n            )\n        ],\n        // 作用：指出应将哪些模块视为外部模块，否则会被打包进最终的代码里\n        external: id => {\n            return !isExternal ? false :\n                (/@babel\\/runtime/.test(id) || /lodash/.test(id));\n        }\n    }\n})\n\nexport default config;\n```\n\n使用`npm start`开启开发模式；使用`npm run build`可以打包出文件；总共导出三种格式文件：cjs、es、umd，umd格式的文件有压缩和未压缩\n\n> start时如果报错“getaddrinfo ENOTFOUND localhost”，参考这篇[方法](https://segmentfault.com/a/1190000015274463)解决\n\n（2）第二种方法：使用rollup api进行打包\n\nbuild文件夹下新增文件：node.config.js、dev.js、build.js\n```javascript\n// node.config.js\nconst json = require('rollup-plugin-json');\nconst resolve = require('rollup-plugin-node-resolve');\nconst commonjs = require('rollup-plugin-commonjs');\nconst babelPlugin = require('rollup-plugin-babel');\nconst { uglify } = require('rollup-plugin-uglify');\nconst path = require('path');\nconst isDev = process.env.NODE_ENV !== 'production';\n\nconst resolveFile = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\n\nmodule.exports.outputs = [\n    {\n        file: resolveFile('lib/index.js'),\n        format: 'cjs',\n        isExternal: true,\n    },\n    {\n        file: resolveFile('es/index.js'),\n        format: 'es',\n        isExternal: true,\n    },\n    {\n        file: resolveFile('dist/index.js'),\n        format: 'umd',\n        name: 'npmLibraryDemo',\n    },\n    {\n        file: resolveFile('dist/index.min.js'),\n        format: 'umd',\n        name: 'npmLibraryDemo',\n        isUglify: true,\n    }\n].map(i => {\n    i.sourcemap = isDev; // 开发模式：开启sourcemap文件的生成\n    return i;\n});\n\nmodule.exports.configFun = function config({isUglify, isExternal} = {}) {\n    return {\n        input: resolveFile('src/main.js'),\n        plugins: [\n            // rollup-plugin-commonjs应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测\n            // 作用：将CommonJS模块转换为 ES2015 供 Rollup 处理\n            commonjs(),\n            // 作用：处理json格式文件\n            json(),\n            // 作用：告诉 Rollup 如何查找外部模块\n            resolve({\n                // 将自定义选项传递给解析插件\n                customResolveOptions: {\n                    moduleDirectory: 'node_modules'\n                }\n            }),\n            babelPlugin({\n                exclude: 'node_modules/**', // 只编译我们的源代码\n                runtimeHelpers: true,\n            }),\n            ...(\n                isUglify ? [ uglify() ] : []\n            )\n        ],\n        // 作用：指出应将哪些模块视为外部模块，否则会被打包进最终的代码里\n        external: id => {\n            return !isExternal ? false :\n                (/@babel\\/runtime/.test(id) || /lodash/.test(id));\n        },\n    }\n};\n```\n\n```javascript\n// dev.js\nconst path = require('path');\nconst serve = require('rollup-plugin-serve');\nconst rollup = require('rollup');\nconst { configFun, outputs } = require('./node.config.js');\n\nconst resolveFile = function (filePath) {\n    return path.join(__dirname, '..', filePath)\n}\n\nlet watchOptions = [];\nconst len = outputs.length;\noutputs.forEach((output, i) => {\n    let options = {\n        isUglify: output.isUglify,\n        isExternal: output.isExternal,\n    }\n    let config = {\n        output,\n        ...configFun(options)\n    };\n    if (i === len - 1) {\n        config.plugins.push(\n            serve({ // 使用开发服务插件\n                port: 3001,\n                // 设置 exmaple的访问目录和dist的访问目录\n                contentBase: [resolveFile('example'), resolveFile('dist')]\n            })\n        );\n    }\n    watchOptions.push(config);\n});\n\nconst watcher = rollup.watch(watchOptions);\n\nwatcher.on('event', event => {\n    // event.code 会是下面其中一个：\n    //   START        — 监听器正在启动（重启）\n    //   BUNDLE_START — 构建单个文件束\n    //   BUNDLE_END   — 完成文件束构建\n    //   END          — 完成所有文件束构建\n    //   ERROR        — 构建时遇到错误\n    //   FATAL        — 遇到无可修复的错误\n    switch (event.code) {\n        case 'START':\n            console.log(`[info] 监听器正在启动（重启）`);\n            break;\n        case 'BUNDLE_START':\n            console.log(`[info] 开始构建 ${event.output}`);\n            break;\n        case 'BUNDLE_END':\n            console.log(`[info] 完成构建 ${event.output}`);\n            console.log(`[info] 构建时长 ${event.duration}`);\n            break;\n        case 'END':\n            console.log(`[info] 完成所有构建`);\n            break;\n        case 'ERROR':\n        case 'FATAL':\n            console.log(`[error] 构建发生错误`);\n    }\n});\n\n// 停止监听\n// watcher.close();\n```\n\n```javascript\n// build.js\nconst rollup = require('rollup');\nconst { configFun, outputs } = require('./node.config.js');\n\noutputs.forEach(async (output) => {\n    const inputOptions = configFun({\n        isUglify: output.isUglify,\n        isExternal: output.isExternal,\n    });\n    build(inputOptions, output);\n})\n\nasync function build(inputOptions, outputOptions) {\n    console.log(`[INFO] 开始编译 ${inputOptions.input}`);\n    // create a bundle\n    const bundle = await rollup.rollup(inputOptions);\n\n    // generate code and a sourcemap\n    const res = await bundle.generate(outputOptions);\n    console.log(`[INFO] ${res}`);\n\n    // or write the bundle to disk\n    await bundle.write(outputOptions);\n    console.log(`[SUCCESS] 编译结束 ${outputOptions.file}`);\n}\n```\n\n使用`npm run node:dev`开启开发模式；使用`npm run node:build`可以打包出文件；\n\n可以实现一个简单功能实验一下配置是否成功，比如这次提交[简单预加载图片](https://github.com/jiaoyanlin/npm-library-demo/commit/e7a48b6f0332cf68a3d888a73867dc565d63da8e)\n\n注意：\n\n1、examp/index.html中引入的js是umd形式的，如果我们的代码中引入了运行时需要使用到的第三方包（例如lodash等），并且没有在index.html手动将该包引入，会导致找不到该包而报错；因此我这里的配置中，输出文件如果是umd格式的，就不配置external，直接将第三方包的代码一起打包进最终的打包文件中；\n\n2、当输出文件是cjs或者es时，配置external，即不将某些第三方包打包，减小最终的打包文件体积；由于我们把第三方包安装在“dependencies”中，当别人加载我们的这个包时，他们的项目会自动安装我们的“dependencies”中所有的包，所以可以加载到我们开发的包中涉及到的第三方包；\n\n3、关于调试\n\n我开发包的过程中用到了两种调试方式：\n\n方法1：直接通过npm start启动时的http://localhost:3001来调试；由于开启了rollup的监听功能，因此当我们修改代码时，会自动构建打包出新代码，只要刷新浏览器就能看到最新的效果；\n\n> 开启source map调试我只在方法1的调试方法中能正常使用\n\n方法2：在项目中调试正在开发的包：\n\n> npm link命令通过链接目录和可执行文件，实现任意位置的npm包命令的全局可执行。\n\n在包目录下执行`npm link`(假设包名为pky-test)；\n\n在项目目录下执行`npm link pky-test`即可使用该包(执行`npm unlink pky-test`可以删除包链接)；\n\n在包目录下执行`npm start`可以实时打包出最新代码\n\n\n#### 6、发布，增加命令实现自动打标签并根据提交记录生成changelog\n\n`npm i -D conventional-changelog-cli`\n\npackage.json\n```json\n{\n    ...,\n    \"scripts\": {\n        ...,\n        \"tag\": \"node ./build/version.js\",\n        \"x\": \"npm --no-git-tag-version version major\",\n        \"y\": \"npm --no-git-tag-version version minor\",\n        \"z\": \"npm --no-git-tag-version version patch\",\n        \"postversion\": \"npm run changelog && git add . && npm run tag\",\n        \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0\",\n        \"prepublishOnly\": \"npm run build\",\n        \"postpublish\": \"npm run clean\"\n    }\n}\n```\n\n新建文件build/version.js：根据packag.json中的version提交代码并且打标签\n```javascript\nconst fs = require('fs');\nconst path = require('path');\nconst pathname = path.resolve(__dirname, '../package.json');\nconst pkg = JSON.parse(fs.readFileSync(pathname, 'utf-8'));\nlet version = pkg.version;\n\nconsole.log('version:', version)\n\nconst exec = require('child_process').exec;\nlet cmdStr = `git commit -m \"v${version}\" && git push && git tag -a \"v${version}\" -m \"${version}\" && git push origin --tags`;\nexec(cmdStr, function (err, stdout, stderr) {\n    console.log('exec:', err, stdout, stderr);\n});\n```\n\n（1）执行`npm run x/y/z`可以改变package.json中的version，然后根据提交的commit信息自动生成changelog，最后会根据version提交代码并打标签；\n\n（2）执行`npm run publish`发布代码\n\n\n\n其他：\n\n（1）我没有使用preversion钩子和\nconventional-changelog-cli自动生成changelog，因为如果在改变版本号之前执行自动生成changelog，那么当前版本提交的commit信息不会被自动生成到changelog中（因为changelog只会生成当前版本之前的commit记录）\n\n（2）必须遵循一定的commit规范，才能根据commit记录自动生成changelog，具体自行百度下conventional-changelog-cli的使用哦\n\n因此，推荐的工作流：\n\n 1.改动代码\n \n 2.提交这些改动\n \n 3.改变package.json中的版本号\n \n 4.使用conventional-changelog工具\n \n 5.提交 package.json和CHANGELOG.md文件\n \n 6.打标签tag\n \n 7.push代码\n\n可以参考[使用conventional-changelog生成版本日志](https://github.com/rayliao/blog/issues/4)\n\n## 三、知识点\n\n> 先学习下以下两篇文章：\n> [如何开发和维护一个npm项目](https://juejin.im/post/5bd32ecff265da0ab33193b4)\n> [你所需要的npm知识储备都在这了](https://juejin.im/post/5d08d3d3f265da1b7e103a4d)\n\n#### 1、package.json中需要注意的点：\n\n（1）version: \n\n版本格式: [主版本号major.次版本号minor.修订号patch]\n\n先行版本: 内部版本alpha、公测版本beta、Release candiate正式版本的候选版本rc，例如1.0.0-alpha、1.0.0-beta.1\n\n使用npm version进行版本号管理：\n\n```\nnpm version 1.0.1  # 显示设置版本号为 1.0.1\nnpm version major  # major + 1，其余版本号归 0\nnpm version minor  # minor + 1，patch 归 0\nnpm version patch  # patch + 1\n\n# 预发布版本\n# 当前版本号为 1.2.3\nnpm version prepatch  # 版本号变为 1.2.4-0，也就是 1.2.4 版本的第一个预发布版本\nnpm version preminor  # 版本号变为 1.3.0-0，也就是 1.3.0 版本的第一个预发布版本\nnpm version premajor  # 版本号变为 2.0.0-0，也就是 2.0.0 版本的第一个预发布版本\nnpm version prerelease  # 版本号变为 2.0.0-1，也就是使预发布版本号加一\n\n# 在git环境下npm version会默认执行git add->git commit->git tag\nnpm version minor -m \"feat(version): upgrade to %s\"  # 可自定义commit message；%s 会自动替换为新版本号\n\n# 模块 tag 管理\n# 当前版本为1.0.1\nnpm version prerelease  # 1.0.2-0\nnpm publish --tag beta # 发布包beta版本，打上beta tag\nnpm dist-tag ls xxx  # 查看某个包的tag；beta: 1.0.2-0\nnpm install xxx@beta  # 下载beta版本 1.0.2-0\n# 当prerelease版本已经稳定了，可以将prerelease版本设置为稳定版本\nnpm dist-tag add xxx@1.0.2-0 latest\nnpm dist-tag ls xxx  # latest: 1.0.2-0\n```\n\nnpm version 可以更新包版本，当仓库已经被git初始化了，那么运行npm version修改完版本号以后，还会运行git add 、git commit和git tag的命令，其中commit的信息默认是自改完的版本号\n\n（2）main、module、sideEffect：\n\n* main、module：用来指定npm包的入口文件\n* main: npm自带，一般表示符合CommonJS规范的文件入口\n* module: 符合ES模块规范的文件入口，使得代码可进行Tree Shaking；并且在webpack的默认配置中，module的优先级要高于main\n\n> 因为一般项目配置babel时，为了加速项目编译过程，会忽略node_modules中的模块，所以module入口的文件最好是符合ESmodule规范的ES5的代码（说白了就是该文件只有导入导出是用的ES6模块化语法，其他都已经转成了es5），webpack最终会把ESmodule转换为它自己的commonjs规范的代码\n\n* sideEffect：webpack4中新增特性，表示npm包的代码是否有副作用；\n\n> sideEffect可设置为Boolean或者数组;当为false时，表明这个包是没有副作用的，可以进行按需引用;如果为数组时，数组的每一项表示的是有副作用的文件在组件库开发的时候，如果有样式文件，需要把样式文件的路径放到sideEffect的数组中，因为UglifyJs只能识别js文件，如果不设置的话，最后打包的时候会把样式文件忽略掉。\n\n由于webpack4引入了sideEffect，因此当第三方包设置了sideEffect时，可以直接去除没有用到的代码，比如antd组件库设置sideEffect，那在webpack4时就不用再依赖babel-plugin-import进行按需加载了，webpack打包时直接就能把没用到的代码通过tree-shaking清除掉。\n\n> 参考文章：\n> [package.json 中的 Module 字段是干嘛的](https://github.com/sunyongjian/blog/issues/37)\n> [聊聊 package.json 文件中的 module 字段](https://loveky.github.io/2018/02/26/tree-shaking-and-pkg.module/)\n\n（3）tree shaking，用来剔除 JavaScript 中用不上的死代码\n\n> 更多详情可参考[使用 Tree Shaking](http://www.xbhub.com/wiki/webpack/4%E4%BC%98%E5%8C%96/4-10%E4%BD%BF%E7%94%A8TreeShaking.html)\n\n要让 Tree Shaking 正常工作的前提是交给 Webpack 的 JavaScript 代码必须是采用 ES6 模块化语法的。 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中），这让 Webpack 可以简单的分析出哪些 export 的被 import 过了。 如果你采用 ES5 中的模块化，例如 module.export={...}、 require(x+y)、 if(x){require('./util')}，Webpack 无法分析出哪些代码可以剔除。\n\n基于以上说明，需要做一些配置让tree shaking生效：\n\n第一种情况--针对项目：\n* 把采用 ES6 模块化的代码直接交给 Webpack，需要配置 Babel 让其保留 ES6 模块化语句，修改 .babelrc 文件如下；要剔除用不上的代码还得经过 UglifyJS 去处理一遍，因此需要在项目中引入UglifyJSPlugin；\n```\n{\n    \"presets\": [\n        [\n            \"env\",\n            {\n                \"modules\": false\n            }\n        ]\n    ]\n}\n```\n* 在package.json中根据实际情况设置sideEffects，详细解释请看上面的第（2）点\n\n第二种情况--针对npm包开发：\n* 提供两份代码，一份采用 CommonJS 模块化语法，一份采用 ES6 模块化语法，package.json 文件中有两个字段：\n\n```\n{\n  \"main\": \"lib/index.js\", // 指明采用 CommonJS 模块化的代码入口\n  \"module\": \"es/index.js\" // 指明采用 ES6 模块化的代码入口；当该代码存在时，webpack会优先加载这个代码\n}\n```\n* 根据情况设置package.json中的sideEffects字段\n\n\n> 关于tree shaking、sideEffects使用请查看：\n> [Tree-Shaking性能优化实践 - 原理篇](https://juejin.im/post/5a4dc842518825698e7279a9)\n> [你的Tree-Shaking并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de) \n> [深入浅出 sideEffects](https://www.lindongzhou.com/article/know-sideEffects) \n> [Webpack 中的 sideEffects 到底该怎么用](https://zhuanlan.zhihu.com/p/40052192)\n> \n\n由文章可知sideEffects并不是在项目真的不存在副作用代码时才可以设置\n\n#### 2、控制npm发布的包包含的文件有以下方式：\n\n* package.json#files：数组，表示可以包含哪些文件，格式和.gitignore的写法一样\n* .npmignore：表示哪些文件将被忽略，格式和.gitignore的写法一样\n* .gitignore：表示要忽略哪些文件\n\n优先级：files > .npmignore > .gitignore\n\n#### 3、package-lock.json:\n\n* package-lock.json把所有依赖按照顺序列出来，第一次出现的包名会提升到顶层，后面重复出现的将会放入被依赖包的node_modules当中，因此会引起不完全扁平化问题。\n* 在开发应用时，建议把package-lock.json文件提交到代码仓库，从而让团队成员、运维部署人员或CI系统可以在执行npm install时安装的依赖版本都是一致的。\n* 但在开发一个库时，则不应把package-lock.json文件提交到仓库中。实际上，npm也默认不会把package-lock.json文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。\n\n#### 4、npm scripts 脚本、npx、path环境变量\n\npackage.json：\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    ...\n}\n```\n\n原理: package.json 中的 bin 字段；字段 bin 表示一个可执行文件到指定文件源的映射。\n\n例如在@vue/cli-service的package.json中：\n\n```\n\"bin\": {\n    \"vue-cli-service\": \"bin/vue-cli-service.js\"\n}\n```\n\nnpx：方便调用项目内部安装的模块\n\nPATH环境变量：执行`env`可查看当前所有环境变量；`npm run env`可查看脚本运行时的环境变量;通过npm run可在不添加路径前缀的情况下直接访问当前项目node_modules/.bin目录里面的可执行文件\n\n#### 5、其他\n\n（1）\n\n```\nnpm outdated # 查看当前项目中可升级的模块\n\nnpm audit [--json]  # 安全漏洞检查；加上--json，以 JSON 格式生成漏洞报告\n\nnpm audit fix # 修复存在安全漏洞的依赖包（自动更新到兼容的安全版本）\n\nnpm audit fix --force # 将依赖包版本号升级到最新的大版本，而不是兼容的安全版本；尽量避免使用--force\n\n```\n\n（2）git提交可参考以下规范：\n\nfeat：新功能（feature）\n\nfix：修补bug\n\ndocs：文档（documentation）\n\nstyle： 格式（不影响代码运行的变动）\n\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\n\ntest：增加测试\n\nchore：构建过程或辅助工具的变动\n\n\n（3）npm包发布流程：\n\n[于Webpack和ES6构建NPM包](https://juejin.im/post/5ac4a4d85188255c4c107e42)\n\n[从dist到es：发一个NPM库，我蜕了一层皮](https://segmentfault.com/a/1190000018242549)\n\n[8102年底如何开发和维护一个npm项目](https://juejin.im/post/5bd32ecff265da0ab33193b4)\n\n\n（4）几点心得：\n\n1、对于webpack构建的项目或者包，在babel中设置`\"modules\": false`其实只是让项目中经过babel转化后的代码（已经是es5）仍然保留 ES6 模块化语句，也就是只有导入导出语句保留es6写法；此时webpack会自动再去转换这里的es6模块化语句；也就是ES6 模块化语句交给webpack自己去转换；\n\n2、对于webpack构建生成的包，不支持导出为es6模块（最终都转成了es5，无法保留ES6 模块化语句不转换），因此如果开发的npm包希望导出多种格式，推荐使用rollup\n\n3、为了加速项目编译过程，一般都会设置忽略编译node_modules中的模块，所以这就需要我们开发的npm包是编译过的；\n\n> 一般来说，用于node环境的包，只要提供符合CMD规范的包，但用于web的包，就要提供更多的选项：\n\n> * lib：符合commonjs规范的文件，一般放在lib这个文件夹里面，入口是mian\n\n> * es：符合ES module规范的文件，一般放在es这个文件夹里面，入口是module\n\n> * dist：经过压缩的文件，一般是可以通过script标签直接引用的文件\n\n"},ddCq:function(n,e){n.exports='# webpack 4 — tree shaking、sideEffects\n\n> 本文仅用于记录学习tree shaking过程中的要点及使用注意事项，不会详细介绍tree-shaking，可以根据本文提到的参考文章进行更细致的学习\n\n### tree-shaking\n\n> 基于ES6模块进行模块静态分析，将没有使用的模块摇掉，达到删除无用代码的目的。\n\n***基于ES6模块进行模块静态分析是什么***\n\n所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。而ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。\n\n这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。\n\n通过限定语法，让本来需要运行代码才能确定的依赖，可以在分析 AST 阶段就确定下来；动态 == 拼字符串，静态 == 不准拼字符串;\n\n总结：要让 Tree Shaking 正常工作的前提是交给 Webpack 的 JavaScript 代码必须是采用 ES6 模块化语法的。 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中），这让 Webpack 可以简单的分析出哪些 export 的被 import 过了。 如果你采用 ES5 中的模块化，例如 module.export={...}、 require(x+y)、 if(x){require(\'./util\')}，Webpack 无法分析出哪些代码可以剔除。\n\n基于以上说明，需要做一些配置让tree shaking生效：\n\n第一种情况--针对项目：\n* 把采用 ES6 模块化的代码直接交给 Webpack，需要配置 Babel 让其保留 ES6 模块化语句，修改 .babelrc 文件如下；要剔除用不上的代码还得经过 UglifyJS 去处理一遍，因此需要在项目中引入UglifyJSPlugin；\n```\n{\n    "presets": [\n        [\n            "env",\n            {\n                "modules": false\n            }\n        ]\n    ]\n}\n```\n* 根据实际情况在package.json中添加设置sideEffects，详细解释请看下面关于sideEffects的介绍\n\n第二种情况--针对npm包开发：\n* 提供两份代码，一份采用 CommonJS 模块化语法，一份采用 ES6 模块化语法，package.json 文件中有两个字段：\n\n```\n{\n  "main": "lib/index.js", // 指明采用 CommonJS 模块化的代码入口\n  "module": "es/index.js" // 指明采用 ES6 模块化的代码入口；当该代码存在时，webpack会优先加载这个代码\n}\n```\n* 根据情况设置package.json中的sideEffects字段\n\n\n### webpack4 sideEffects配置\n\n> 由于副作用的存在，使得webpack没办法很好地进行tree shaking；如果使用sideEffects标记，让webpack知道我们期望整个项目都是无副作用的，那么可以让webpack更好地清除多余的代码（要仔细评估我们的项目/包真的不需要这些副作用）\n\n> 副作用：某个方法或者文件执行了之后，还会对全局其他内容产生影响的代码；比如给window加全局变量等\n\n```\ndemo\n    |--src\n        |--util\n            |-- index.js\n            |-- a.js\n            |-- b.js\n        |--main.js\n```\n\n```javascript\n// util/a.js\nconsole.log(\'----------a.js\')\nwindow.util = \'----------a.js\';\nexport function a_1() {\n    console.log(\'----------a_1\')\n}\nexport function a_2() {\n    console.log(\'----------a_2\')\n}\n```\n\n```javascript\n// util/b.js\nconsole.log(\'----------b.js\')\nwindow.util = \'----------b.js\';\nexport function b_1() {\n    console.log(\'----------b_1\')\n}\nexport function b_2() {\n    console.log(\'----------b_2\')\n}\n```\n\n```javascript\n// util/index.js\nexport * from "./a";\nexport * from "./b";\n```\n\n```javascript\n// main.js\nimport { a_1 } from \'./util\';\na_1();\n```\n\n配置基础的webpack进行打包（记得使用production模式）\n\n（1）当package.json不配置sideEffects时：\n\npackage.json\n```\n{\n    name: \'test\'\n}\n```\n\n此时使用webpack打包生成的文件简化后代码如下：\n```javascript\n...\nfunction(o,n,s){\n    "use strict";\n    s.r(n),\n    console.log("----------a.js"),\n    window.util="----------a.js",\n    console.log("----------b.js"),\n    window.util="----------b.js",\n    console.log("----------a_1")\n}\n...\n```\n\n（2）当package.json配置sideEffects时：\n\npackage.json\n```\n{\n    name: \'test\',\n    "sideEffects": false\n}\n```\n\n此时使用webpack打包生成的文件简化后代码如下：\n```javascript\n...\nfunction(o,n,i){\n    "use strict";\n    i.r(n),\n    console.log("----------a.js"),\n    window.util="----------a.js",\n    console.log("----------a_1")\n}\n...\n```\n\n注意点：\n\n1、sideEffects：sideEffect可设置为Boolean或者数组（传要保留副作用的文件或模糊匹配）;当为false时，表明这个包是没有副作用的，可以进行按需引用;如果为数组时，数组的每一项表示的是有副作用的文件在组件库开发的时候，如果有样式文件，需要把样式文件的路径放到sideEffect的数组中，因为UglifyJs只能识别js文件，如果不设置的话，最后打包的时候会把样式文件忽略掉\n\n实际开发中，有些副作用是必须要保留的，因此不能简单设置"sideEffects": false；webpack会认为所有 `import \'xxx\'` 语句是仅引入而未使用\n\npackage.json:\n```\n"sideEffects": [\n    "./style/**/*.css",\n    "./polyfill.js"\n]\n```\n\n> tree-shaking仅在production模式生效，如果某些必须的文件因为没有正确设置sideEffects而被tree-shaking掉，会导致生产环境出现问题\n\n2、sideEffects 局限性：sideEffects 配置是以文件为维度的, 只要你使用了具备副作用的文件中的某个模块, 即便你只用了该文件中没有副作用的那部分功能, 仍然会将该文件的副作用保留\n\n举例：在 main.js 中增加 b_1 方法的引入, b_2 方法会被 tree-shaking, 但 `console.log(\'----------b.js\');window.util = \'----------b.js\';` 不会。\n\n3、sideEffects 配置可能会让人疑惑, 代码明明是有副作用的, 为什么可以设置它是"无副作用"?其实 sideEffects 并不是在项目真的不存在副作用代码时才可以设置，是告诉 webpack 该模块是可以安全的 tree-shaking 的, 无需关心其副作用。\n\n4、在项目中配置package.json的sideEffects会影响本项目的源码打包，不会影响npm依赖包的“副作用”打包；引入npm依赖包时，会根据该npm依赖包package.json的sideEffects的配置来确定引入的相关代码是否消除“副作用”。\n\n因此，开发npm包的时候可根据情况设置sideEffects，根据情况尽量以单独的形式输出。\n\n> 由于webpack4引入了sideEffect，因此当第三方包设置了sideEffect时，可以直接去除没有用到的代码，比如antd组件库设置sideEffect，那在webpack4时就不用再依赖babel-plugin-import进行按需加载了，webpack打包时直接就能把没用到的代码通过tree-shaking清除掉。\n\n### 参考文章\n\n[package.json 中的 Module 字段是干嘛的](https://github.com/sunyongjian/blog/issues/37)\n\n[聊聊 package.json 文件中的 module 字段](https://loveky.github.io/2018/02/26/tree-shaking-and-pkg.module/)：根据package.json中的module字段可以让webpack优先使用es模块规范的代码\n\n[使用 Tree Shaking](http://www.xbhub.com/wiki/webpack/4%E4%BC%98%E5%8C%96/4-10%E4%BD%BF%E7%94%A8TreeShaking.html)：该文章中有些用法太旧了，因此大概看下了解下tree-shaking是啥就可以了\n\n[静态分析](https://www.zhihu.com/question/63240671)：告诉你什么是静态分析\n\n[你的Tree-Shaking并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de) \n\n[深入浅出 sideEffects](https://www.lindongzhou.com/article/know-sideEffects)\n\n[Webpack 中的 sideEffects 到底该怎么用](https://zhuanlan.zhihu.com/p/40052192)\n\n[Tree-Shaking性能优化实践 - 原理篇](https://juejin.im/post/5a4dc842518825698e7279a9)\n\n[Tree-Shaking性能优化实践 - 实践篇](https://juejin.im/post/5a4dca1d518825128654fa78)\n\n[Webpack Tree shaking 深入探究](https://www.codercto.com/a/30428.html)\n\n[webpack 4 新增 sideEffects 配置的作用和注意事项](https://juejin.im/post/5d4d39c35188256c234351ca)\n\n'},gAYf:function(n,e){n.exports="# React-Native开发：react-native-file-selector选择文件组件的使用（安卓）\n\n> 为了上传文件，搜索了很多资料终于找到选择本地文件并获取到具体路径的组件，可以在github上查找到[该组件](https://github.com/prscX/react-native-file-selector)\n\n以下为该组件使用前的引入工作：\n\n1、`npm install react-native-file-selector --save`\n\n2、`react-native link react-native-file-selector`\n\n3、/app/build.gradle：\n\n增加`<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>`\n\n4、MainApplication.java：\n\n`import ui.fileselector.RNFileSelectorPackage; // 增加这句`\n\n```\n...\nprotected List<ReactPackage> getPackages() {\n    return Arrays.<ReactPackage>asList(\n        new MainReactPackage(),\n        new RNFileSelectorPackage(), // 增加这句\n        new PickerPackage()\n    );\n}\n...\n```\n\n5、增加文件android/app/src/main/res/values/colors.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"colorPrimary\">#3F51B5</color>\n    <color name=\"colorPrimaryDark\">#303F9F</color>\n    <color name=\"colorAccent\">#FF4081</color>\n</resources>\n```\n\n6、android/build.gradle：\n\n在allprojects的repositories中增加`maven { url \"http://dl.bintray.com/lukaville/maven\" }`\n\n在该文件末尾增加(这里根据情况决定是否添加，我是在后来运行项目报错时根据google搜索到的方案添加的)：\n\n```\nsubprojects {\n    afterEvaluate {project ->\n        if (project.hasProperty(\"android\")) {\n            android {\n                compileSdkVersion 25\n                buildToolsVersion '25.0.0'\n            }\n        }\n    }\n}\n```\n\n7、settings.gradle：\n\n```\ninclude ':react-native-file-selector'\nproject(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android')\n```\n\n8、使用方法：\n\n```\nimport RNFileSelector from 'react-native-file-selector';\n\nRNFileSelector.Show(\n\t{\n\t\ttitle: '请选择文件',\n\t\tonDone: (path) => {\n\t\t\t_uploadFile('file://' + path) // 根据官方给的fetch方法封装的上传方法\n\t\t},\n\t\tonCancel: () => {\n\t\t\tconsole.log('cancelled')\n\t\t}\n\t}\n)\n```\n\n9、关于上传文件或图片到服务端，其实就是利用官方给的fetch方法，注意点是参数必须使用formData的形式，其中的文件对应的数据是这样的{ uri: filePath, type: 'multipart/form-data', name: fileName }，其中的filePath是8中的文件路径。\n\nps：后期有需要再补充相关的get与post封装（不过网上已经有很多了，可以自行百度或google）\n\n10、上面的相关步骤（1-7）修改后可以尝试看看能不能运行成功，不行的话就将项目中的node_modules移除并重新安装依赖，尝试在Android Studio rebuild一下，再重新运行试试，多试几次就可以成功了。\n"},jE9Z:function(n,e,t){n.exports=t("JG2H")(6)},kKVl:function(n,e){n.exports="# Node.js+Express+MongoDB 建站实例（2）—— 登录模块\n\n1、 准备工作：\n\n> 安装token相关工具，用于登录验证：`npm install jsonwebtoken --save`\n\n> 在/routes/db.js中添加查找方法（只查询一个）：\n\n```javascript\n// 查找单个数据\nexports.findOne = function(collectionName, queryJson, callback) {\n\t_connectDB(function(err, db) {\n\t\tdb.collection(collectionName).findOne(queryJson, function(err, results) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, null)\n\t\t\t\tdb.close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcallback(err, results)\n\t\t\tdb.close()\n\t\t})\n\t})\n}\n```\n\n> 修改/routes/setting.js\n\n```javascript\nlet md5 = require('./md5.js')\nlet user = 'test'\nlet pwd = md5('test') // 密码加密处理，防止被窃取真实密码\nmodule.exports = {\n    dbUrl: 'mongodb://localhost:27017/myproject1',\n    user: user,\n    pwd: pwd\n}\n```\n\n> 新增/routes/md5.js\n\n```javascript\nlet crypto = require('crypto')\nmodule.exports = function (content) {\n    let md5 = crypto.createHash('md5')\n    let newContent = md5.update(content).digest('base64')\n    return newContent\n}\n```\n\n2、 在/routes/index.js中添加接口\n\n```javascript\n// 登录模块\nrouter.post('/api/login', api.login)\n```\n3、 在/routes/api.js中添加\n\n```javascript\nconst jwt = require('jsonwebtoken')\n// 登录\nexports.login = function(req, res, next) {\n  let user = req.body.user, pwd = md5(req.body.pwd);\n  // 根据用户名查询数据库中是否含有该用户\n  db.findOne('users', { \"user\": user }, function(err, result) {\n    if (err) {\n\t\treturn res.json({\n\t\t\t\"code\": 500,\n\t\t\t\"message\": \"内部服务器错误\"\n\t\t})\n    }\n\n    if (!result || result.length === 0) {\n\t\treturn res.json({\n\t\t\t\"code\": 401,\n\t\t\t\"message\": \"找不到用户名\"\n\t\t})\n    }\n\n    let dbPassword = result.pwd\n    let id = result._id\n    let expires = 60 * 60 * 24 * 30\n    if (dbPassword === pwd) {\n        // 根据查询到的id、user按照一定的加密方式生成token，并且缓存在cookie中，后期当用户使用别的接口的时候我们可以直接通过req.cookies.token获取到token，此时根据该用户的id和user利用同样的方法解密得到对应的user和id，将新旧数据对比即可知道该token是否为正确登录的token\n        let token = jwt.sign({ id, user }, 'secret', { expiresIn: expires })\n        res.cookie('token', token, { maxAge: expires })\n        res.cookie('id', id, { maxAge: expires })\n        res.cookie('user', user, { maxAge: expires })\n        return res.json({\n            \"code\": 200,\n            \"message\": \"登录成功\"\n        })\n    } else {\n\t\treturn res.json({\n\t\t\t\"code\": 401,\n\t\t\t\"message\": \"密码错误\"\n\t\t})\n    }\n  })\n}\n```\n\n> 关于jsonwebtoken的原理及使用可以参考：http://www.jianshu.com/p/a7882080c541\n\n4、 举例看下token验证方法：\n\n> 新增 /routes/verify-token.js\n\n```javascript\nconst jwt = require('jsonwebtoken')\nmodule.exports = (req, res, next) => {\n\tlet token = req.cookies.token; // 获取cookies中的token\n\tlet user = req.cookies.user;\n\tlet id = req.cookies.id;\n\tif (token) {\n\t\tjwt.verify(token, 'secret', function(err, decoded) { // 与加密时使用同样的方法对token进行解密\n\t\t\tif (!err && decoded.user === user && decoded.id === id) { // token正确就进入下一个方法继续执行，否则就清空cookie\n\t\t\t\treq.decoded = decoded\n\t\t\t\tnext()\n\t\t\t} else {\n\t\t\t\tres.cookie('token', '', { maxAge: 0 })\n\t\t\t\tres.cookie('user', '', { maxAge: 0 })\n\t\t\t\tres.cookie('id', '', { maxAge: 0 })\n\t\t\t\treturn res.json({\n\t\t\t\t\t\"code\": 401,\n\t\t\t\t\t\"message\": \"登录失败\"\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t} else {\n\t\treturn res.json({\n\t\t\t\"code\": 401,\n\t\t\t\"message\": \"请登录后操作\"\n\t\t})\n\t}\n}\n```\n\n> 在/routes/index.js中使用：将addtest方法修改为登录后才可以使用\n\n```javascript\nconst verifyToken = require('./verify-token.js')\nrouter.route('/api/addtest').all(verifyToken).post(api.addtest) // 先验证是否有正确的token，正确才能进行下一步提交\n```\n此时，因为没有进行登录，所以提交test会失败，只需要在/views/index.ejs中加入以下代码：\n```javascript\n$.post('/api/login', {\n\tuser: 'test',\n\tpwd: 'test'\n}, function (data) {\n\tconsole.log('----login', data)\n})\n```\n刷新浏览器已经登录成功，此时再进行提交test就会成功了。\n\n5、 此部分代码请看这个commit\nhttps://github.com/jiaoyanlin/myNodeProject/tree/20e9faa837ac69580aa450962efd4af02d891a8b\n"},lg5E:function(n,e){n.exports="# webpack4搭建项目\n\n> 最近学习webpack相关知识，特此记录下学习过的文档以及搭建过程；如有错误，记得告诉我呀。项目地址：[地址](https://github.com/jiaoyanlin/webpack-demo),求星星\n\n```javascript\n// 1、clone代码到本地\ncd vue-demo\nnpm i\n// 通过package.json的scripts可以看到区分了不同环境的启动命令\nnpm run dev:local // 例如：启动\nnpm run build // 打包\n```\n\n[TOC]\n\n## vue项目搭建\n\n> 传送门：相关代码都在[这里](https://github.com/jiaoyanlin/webpack-demo/tree/master/vue-demo)哦！\n\ntips: 当前项目搭建时环境及使用的部分工具版本（版本不同可能导致使用方法不同）：node v11.6.0, npm v6.10.0, webpack: ^4.35.0, webpack-cli: ^3.3.5, 其他请看package.json\n\n### 1、初始化项目:\n\n1.新建vue-demo, cd vue-demo, npm init初始化项目；\n\n2.安装相关依赖：\n\nwebpack: `npm i webpack webpack-cli webpack-dev-server webpack-merge --save-dev`\n\nvue: `npm i vue --save`、`npm i vue-loader vue-template-compiler --save-dev`\n\nhtml解析：`npm i html-webpack-plugin --save-dev`\n\ncss、scss相关：`npm i css-loader style-loader node-sass sass-loader --save-dev`\n\ncss后处理：`npm i postcss-loader autoprefixer --save-dev`\n\n图片路径处理：`npm i file-loader url-loader --save-dev`\n\n以下为打包时用到的插件，放在webpack.prod.js：\n\n清理dist文件夹：`npm i clean-webpack-plugin --save-dev`\n\n3.创建相关文件如下：\n\n```text\nvue-demo\n    |--build\n        |--webpack.base.js\n        |--webpack.dev.js\n        |--webpack.prod.js\n    |--src\n        |--static\n            |--images\n            |--scss\n                |--index.scss\n        |--views\n            |--app.vue\n        |--index.js\n        |--index.html\n    |--postcss.config.js\n    |--favicon.png\n```\n```javascript\n// webpack.base.js 公用配置文件\nconst webpack = require('webpack');\nconst path = require(\"path\");\nconst VueLoaderPlugin = require('vue-loader/lib/plugin'); // vue-loader\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // html\nmodule.exports = {\n    entry: { \n        index: path.resolve(__dirname, '../src/index.js'), \n    },\n    resolve: {\n        alias: { // 别名\n            '@src': path.resolve(__dirname, '../src'),\n            '@views': path.resolve(__dirname, '../src/views'),\n            '@scss': path.resolve(__dirname, '../src/static/scss'),\n            '@images': path.resolve(__dirname, '../src/static/images'),\n        },\n        extensions: ['.js', '.vue'], // 配置扩展名\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.vue$/,\n                loader: 'vue-loader'\n            },\n            {\n                test: /\\.(scss|css)$/,\n                use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],\n            },\n            {\n                test: /\\.(png|svg|jpg|jpeg|gif)$/,\n                // 使用url-loader, 它接受一个limit参数，单位byte；\n                // 当文件小于limit：将文件转为Data URI格式内联到引用的地方\n                // 当文件大于limit：将调用 file-loader, 把文件复制到输出目录，并将引用的文件路径改写成输出后的路径\n                use: [\n                    {\n                        loader: 'url-loader',\n                        options: {\n                            limit: 20 * 1024,\n                            // 分离图片至imgs文件夹\n                            name: \"imgs/[name].[ext]\",\n                        }\n                    },\n                ]\n            },\n        ]\n    },\n    plugins: [ // 插件\n        new VueLoaderPlugin(),\n        new HtmlWebpackPlugin({\n            template: path.resolve(__dirname, '../src/index.html'), // html模板\n            favicon: path.resolve(__dirname, '../favicon.png'),\n        }),\n    ],\n};\n```\n```javascript\n// webpack.dev.js 开发环境配置文件\nconst path = require('path');\nconst merge = require('webpack-merge'); // 合并配置文件\nconst common = require('./webpack.base.js');\n\nmodule.exports = merge(common, {\n    mode: 'development',\n    devtool: 'inline-source-map',\n    devServer: { // 开发服务器\n        port: '3000',\n        // open: false, // 可以设置是否每次启动都自动打开浏览器页面\n        contentBase: '../dist',\n        host: '0.0.0.0', // 可通过IP访问，也可以通过localhost访问\n        useLocalIp: true, // browser open with your local IP\n    },\n    output: { // 输出\n        filename: 'js/[name].[hash].js', // 每次保存 hash 都变化\n        path: path.resolve(__dirname, '../dist')\n    },\n    module: {},\n});\n```\n```javascript\n// webpack.prod.js 生产环境的配置文件\nconst path = require('path');\nconst merge = require('webpack-merge');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin'); // 清理dist文件夹\nconst common = require('./webpack.base.js');\n\nmodule.exports = merge(common, {\n    mode: 'production',\n    output: {\n        filename: 'js/[name].[contenthash:8].js', // 若文件内容无变化，则contenthash不变\n        path: path.resolve(__dirname, '../dist')\n    },\n    module: {},\n    plugins: [\n        new CleanWebpackPlugin(),\n    ],\n});\n```\n```javascript\n// index.js\nimport Vue from 'vue'\nimport App from './views/app.vue'\nimport '@scss/index.scss'\nnew Vue({\n    el: '#app',\n    render: h => h(App),\n});\n```\n```\n\x3c!-- app.vue --\x3e\n<template>\n    <div id=\"app\">\n        hello, vue-demo\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'app'\n}\n<\/script>\n\n<style lang=\"scss\" scoped>\n#app {\n  text-align: center;\n  color: #333;\n  margin-top: 100px;\n  display: flex;\n}\n</style>\n```\n```html\n\x3c!-- index.html --\x3e\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>webpack-vue-demo</title>\n    </head>\n    <body>\n        <div id=\"app\"></div>\n    </body>\n</html>\n```\n```javascript\n// postcss.config.js css兼容前缀\nmodule.exports = {\n    plugins: {\n        'autoprefixer': {\n            overrideBrowserslist: [\n                'Android 4.1',\n                'iOS 7.1',\n                'Chrome > 31',\n                'ff > 31',\n                'ie >= 8'\n            ]\n        }\n    }\n}\n```\n\n4.npm命令：\n```\n\"scripts\": {\n  \"start\": \"webpack-dev-server --hot --progress --config build/webpack.dev.js\",\n  \"build\": \"webpack --progress --config build/webpack.prod.js\"\n},\n```\n现在，执行`npm start`即可体验项目啦~`npm run build`可以打包项目\n\n### 2、引入babel7\n\n> @babel/preset-env 语法装换，配置 polyfill及按需加载；@babel/plugin-transform-runtime复用辅助函数\n\n1.安装依赖：\n\n`npm i babel-loader @babel/core @babel/cli --save-dev`\n\n`npm i @babel/preset-env @babel/plugin-transform-runtime --save-dev`\n\n`npm i @babel/polyfill @babel/runtime --save`\n\n2.配置loader：\n\n```javascript\n// webpack.base.js\n// module.rules中添加\n{\n    test: /\\.js$/,\n    use: ['babel-loader'],\n    exclude: /node_modules/, // 排除不要加载的文件夹\n    include: path.resolve(__dirname, '../src') // 指定需要加载的文件夹\n},\n```\n\n3.配置babel，在根目录下添加文件.babelrc.js\n\n```javascript\nmodule.exports = {\n    presets: [\n        [\n            \"@babel/preset-env\",\n            {\n                \"corejs\": 2,\n                \"modules\": false, // 模块使用 es modules ，不使用 commonJS 规范 \n                \"useBuiltIns\": 'usage', // 默认 false, 可选 entry , usage；usage表示按需加载\n            }\n        ]\n    ],\n    plugins: [\n        [\n            \"@babel/plugin-transform-runtime\",\n            {\n                \"corejs\": false, // 默认值，可以不写\n                \"helpers\": true, // 默认，可以不写\n                \"regenerator\": false, // 通过 preset-env 已经使用了全局的 regeneratorRuntime, 不再需要 transform-runtime 提供的 不污染全局的 regeneratorRuntime\n                \"useESModules\": true, // 使用 es modules helpers, 减少 commonJS 语法代码\n            }\n        ],\n    ]\n}\n```\n\n### 3、引入其他工具、组件库\n\n##### 1.eslint:\n\n安装依赖：`npm i babel-eslint eslint eslint-friendly-formatter eslint-loader eslint-plugin-vue -D`\n\n```javascript\n// 根目录下新建文件 .eslintrc.js:\nmodule.exports = {\n    //一旦配置了root，ESlint停止在父级目录中查找配置文件\n    root: true,\n    //想要支持的JS语言选项\n    parserOptions: {\n        //启用ES6语法支持(如果支持es6的全局变量{env: {es6: true}}，则默认启用ES6语法支持)\n        //此处也可以使用年份命名的版本号：2015\n        ecmaVersion: 6,\n        //默认为script\n        sourceType: \"module\",\n        //支持其他的语言特性\n        ecmaFeatures: {},\n        parser: \"babel-eslint\"\n    },\n    //代码运行的环境，每个环境都会有一套预定义的全局对象，不同环境可以组合使用\n    env: {\n        amd: true, // 否则会出现'require' is not defined 提示\n        es6: true,\n        browser: true,\n        jquery: true\n    },\n    //访问当前源文件中未定义的变量时，no-undef会报警告。\n    //如果这些全局变量是合规的，可以在globals中配置，避免这些全局变量发出警告\n    globals: {\n        //配置给全局变量的布尔值，是用来控制该全局变量是否允许被重写\n        test_param: true,\n        window: true,\n    },\n    //支持第三方插件的规则，插件以eslint-plugin-作为前缀，配置时该前缀可省略\n    //检查vue文件需要eslint-plugin-vue插件\n    plugins: [\"vue\"],\n    //集成推荐的规则\n    extends: [\"eslint:recommended\", \"plugin:vue/essential\"],\n    globals: {\n        process: false,\n    },\n    //启用额外的规则或者覆盖默认的规则\n    //规则级别分别：为\"off\"(0)关闭、\"warn\"(1)警告、\"error\"(2)错误--error触发时，程序退出\n    rules: {\n        //关闭“禁用console”规则\n        \"no-console\": \"off\",\n        //缩进不规范警告，要求缩进为2个空格，默认值为4个空格\n        \"indent\": [\"warn\", 4, {\n            //设置为1时强制switch语句中case的缩进为2个空格\n            \"SwitchCase\": 1,\n        }],\n        // 函数定义时括号前面要不要有空格\n        \"space-before-function-paren\": [0, \"always\"],\n        //定义字符串不规范错误，要求字符串使用双引号\n        // quotes: [\"error\", \"double\"],\n        //....\n        //更多规则可查看http://eslint.cn/docs/rules/\n    }\n}\n```\n\n```javascript\n// webpack.base.js\n// module.rules中添加\n{\n    test: /\\.(js|vue)$/,\n    loader: 'eslint-loader',\n    enforce: 'pre',\n    // 指定检查的目录\n    include: [path.resolve(__dirname, '../src')],\n    // eslint检查报告的格式规范\n    options: {\n        formatter: require('eslint-friendly-formatter')\n    }\n},\n```\n\n运行项目，根据eslint提示修改不规范的代码\n\n##### 2.vue-router\n\n`npm i @babel/plugin-syntax-dynamic-import -D`\n\n`npm i vue-router -S`\n\n```javascript\n// .babelrc.js\nmodule.exports = {\n    plugins: [\n        \"@babel/plugin-syntax-dynamic-import\", // 支持路由懒加载：()=>import('...')\n        ...\n    ],\n    ...\n}\n```\n```javascript\n// src/index.js改成如下\nimport '@scss/index.scss';\nimport Vue from 'vue';\nimport router from '@src/router/index.js';\nimport App from '@views/app.vue';\n\nnew Vue({\n    el: '#app',\n    router,\n    render: h => h(App),\n});\n```\n\n```javascript\n// 新增文件 src/router/index.js\nimport Vue from 'vue';\nimport VueRouter from 'vue-router';\nimport Test from '../views/test';\nimport NoFound from '@views/noFound';\n\nVue.use(VueRouter);\n\nexport default new VueRouter({\n    // mode: 'history',  // 使用history防止url中出现#\n    routes: [\n        {\n            path: '/',\n            name: 'test',\n            component: Test\n        }, {\n            path: '/test1',\n            name: 'test1',\n            component: () =>\n                import(/* webpackChunkName: \"test1\" */ '@views/test1.vue'),\n        }, {\n            path: '*',\n            name: 'noFound',\n            component: NoFound\n        }\n    ]\n});\n```\n\n新增文件 src/views/app.vue\n\n```\n<template>\n    <div id=\"app\">\n        <div class=\"header\">\n            <router-link to=\"/\">首页</router-link>\n            <router-link to=\"/test1\">test1</router-link>\n            <router-link to=\"/a\">noFound</router-link>\n        </div>\n        <router-view></router-view>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'app',\n};\n<\/script>\n\n<style lang=\"scss\" scoped>\n#app {\n    font-family: \"Avenir\", Helvetica, Arial, sans-serif;\n    text-align: center;\n    margin-top: 60px;\n    transform: rotate(0deg);\n}\n</style>\n```\n\n新增文件 src/views/noFound.vue\n\n```\n<template>\n    <div>\n        noFound\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'noFound',\n};\n<\/script>\n```\n\n新增文件 src/views/test.vue\n\n```\n<template>\n    <div>\n        首页：test\n        <div>{{msg}}</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'test',\n    data() {\n        return {\n            msg: '首页信息'\n        }\n    },\n};\n<\/script>\n```\n\n修改文件 src/views/test1.vue成一下内容；并且在src/static/images下面新增1.jpg,2.jpg,smart.gif\n\n```\n<template>\n    <div>\n        <div>\n            test1, count : \n            <span class=\"red\">{{loading ? 'loading...' : count}}</span>\n        </div>\n        <div>\n            <div class=\"btn\" @click=\"addCount\">add count</div>\n        </div>\n        <div class=\"wrap\">\n            <div>\n                <div>gif</div>\n                <img src=\"@images/smart.gif\" alt=\"\">\n            </div>\n            <div>\n                <div>1</div>\n                <img src=\"@images/1.jpg\" alt=\"\">\n            </div>\n            <div>\n                <div>2</div>\n                <img src=\"@images/2.jpg\" alt=\"\">\n            </div>\n            <div>\n                <div>3</div>\n                <div class=\"img-bg-1\"></div>\n            </div>\n            <div>\n                <div>4</div>\n                <div class=\"img-bg-2\"></div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'test',\n    data() {\n        return {\n            loading: false,\n            count: 1,\n        }\n    },\n    methods: {\n        addCount() {\n            if (this.loading) return ;\n            return new Promise((resolve) => {\n                this.loading = true;\n                setTimeout(() => {\n                    const {count} = this;\n                    this.count = count + 1;\n                    this.loading = false;\n                    resolve();\n                }, 2000);\n            });\n        },\n    },\n};\n<\/script>\n\n<style lang=\"scss\" scoped>\n$red: #a00;\n.red {\n    color: $red;\n}\nimg {\n    width: 100px;\n}\n@mixin img-bg {\n    width: 100%;\n    height: 120px;\n    background-size: 100px;\n}\n.img-bg-1 {\n    background: url(~@images/1.jpg) no-repeat center top;\n    @include img-bg();\n}\n.img-bg-2 {\n    background: url(~@images/2.jpg) no-repeat center top;\n    @include img-bg();\n}\n.wrap {\n    display: flex;\n    &>div {\n        flex: 1;\n    }\n}\n</style>\n```\n\n修改src/static/scss/index.scss\n\n```\n.btn {\n    display: inline-block;\n    padding: 5px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    cursor: pointer;\n}\n```\n\n##### 3.vuex\n\n`npm i vuex vuex-router-sync -S`\n\n```javascript\n// 修改src/index.js\n...\nimport { sync } from 'vuex-router-sync';\nimport store from '@src/store/index';\n\n// 链接vuex和vue-router\nsync(store, router);\n\nnew Vue({\n    ...\n    store, // 新增这一行\n    ...\n});\n\n```\n\n新增如下文件：\n\n```text\n|--src\n    |--store\n        |--actions.js\n        |--getters.js\n        |--index.js\n        |--mutations.js\n        |--state.js\n```\n\n```javascript\n// actions.js\nexport const changeMsg = ({ commit }) => {\n    commit({\n        type: 'mutationsMsg', // 对应mutation.js中的mutationsMsg方法\n        globalMsg: '我是修改后的全局数据~~~'\n    });\n};\n```\n\n```javascript\n// getters.js\nexport const gettersMsg = state => state.globalMsg;\n```\n\n```javascript\n// index.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport * as actions from './actions';\nimport * as mutations from './mutations';\nimport * as getters from './getters';\nimport state from './state';\nVue.use(Vuex);\nconst store = new Vuex.Store({\n    state,\n    getters,\n    actions,\n    mutations\n});\nexport default store;\n```\n\n```javascript\n// mutations.js\nexport const mutationsMsg = (state, payload) => {\n    state.globalMsg = payload.globalMsg;\n}\n```\n\n```javascript\n// state.js\nconst state = {\n    globalMsg: '我是全局数据',\n}\nexport default state;\n```\n\n具体使用\n\n```javascript\n// test.uve\n<template>\n    <div>\n        首页：test\n        <div>{{gettersMsg}}</div>\n        <div class=\"btn\" @click=\"changeMsg\">点击改变数据</div>\n    </div>\n</template>\n\n<script>\nimport { mapGetters, mapActions } from 'vuex';\nexport default {\n    name: 'test',\n    data() {\n        return {};\n    },\n    computed: { ...mapGetters(['gettersMsg']) },\n    methods: { ...mapActions(['changeMsg']) }\n};\n<\/script>\n```\n\n##### 4.antd\n\n`npm i babel-plugin-import less less-loader -D`\n\n`npm i ant-design-vue -S`\n\n```javascript\n// .babelrc.js plugins数组中增加\nplugins: [\n    ...,\n    [\"import\", { \"libraryName\": \"ant-design-vue\", \"libraryDirectory\": \"es\", \"style\": true }], // ant组件按需加载\n]\n```\n\n```javascript\n// webpack.base.js rules中加入\n{\n    test: /\\.less$/,\n    use: [\n        'style-loader',\n        'css-loader',\n        {\n            loader: 'less-loader', // compiles Less to CSS\n            options: { // ant自定义主题\n                modifyVars: {\n                    'primary-color': '#63937d',\n                    'link-color': '#11b96c',\n                    'item-hover-bg': '#547c6a',\n                    'item-active-bg': '#466657',\n                },\n                javascriptEnabled: true,\n            },\n        }\n    ]\n}\n```\n\n```javascript\n// src/index.js 新增一句\nimport '@src/plugins';\n```\n\n```javascript\n// 新增文件 src/plugins/index.js\nimport './ant';\n```\n\n```javascript\n// 新增文件 src/plugins/ant/index.js\nimport Vue from 'vue';\nimport {\n    Button,\n    Icon,\n    Layout,\n    Breadcrumb,\n    Dropdown,\n    Divider,\n    Menu,\n    Pagination,\n    Steps,\n    Checkbox,\n    DatePicker,\n    Input,\n    InputNumber,\n    Radio,\n    Select,\n    Switch,\n    TimePicker,\n    Popover,\n    Tabs,\n    Tag,\n    Tooltip,\n    Alert,\n    message,\n    Modal,\n    Popconfirm,\n    Spin,\n    ConfigProvider,\n    LocaleProvider\n} from 'ant-design-vue';\n\nVue.use(Button);\nVue.use(Icon);\nVue.use(Layout);\nVue.use(Breadcrumb);\nVue.use(Dropdown);\nVue.use(Divider);\nVue.use(Menu);\nVue.use(Pagination);\nVue.use(Steps);\nVue.use(Checkbox);\nVue.use(DatePicker);\nVue.use(Input);\nVue.use(InputNumber);\nVue.use(Radio);\nVue.use(Select);\nVue.use(Switch);\nVue.use(TimePicker);\nVue.use(Popover);\nVue.use(Tabs);\nVue.use(Tag);\nVue.use(Tooltip);\nVue.use(Alert);\nVue.use(Modal);\nVue.use(Popconfirm);\nVue.use(Spin);\nVue.use(ConfigProvider);\nVue.use(LocaleProvider);\nmessage.config({\n    duration: 2,\n    maxCount: 3,\n});\nVue.prototype.$message = message;\nVue.prototype.$Modal = Modal;\n```\n\n使用\n\n```javascript\n// 修改views/test.vue\n<a-button type=\"primary\">点击</a-button>\n```\n\n### 4、优化\n\n##### 1.根据不同分环境配置参数、设置全局变量、优化打包信息：\n\n> 开发和生产环境都区分三种接口配置：本地、测试、正式\n\n```javascript\n// package.json scripts改成：\n\"dev:local\": \"webpack-dev-server --env.CUSTOM_ENV=local --hot --progress --config build/webpack.dev.js\",\n\"dev:pre\": \"webpack-dev-server --env.CUSTOM_ENV=pre --hot --progress --config build/webpack.dev.js\",\n\"dev\": \"webpack-dev-server --env.CUSTOM_ENV=pro --hot --progress --config build/webpack.dev.js\",\n\"build:local\": \"webpack --progress --env.CUSTOM_ENV=local --config build/webpack.prod.js\",\n\"build:pre\": \"webpack --progress --env.CUSTOM_ENV=pre --config build/webpack.prod.js\",\n\"build\": \"webpack --progress --env.CUSTOM_ENV=pro --config build/webpack.prod.js\"\n```\n\n```javascript\n// .eslintrc.js 新增配置\nmodules.exports = {\n    ...\n    globals: {\n        ...\n        process: false,\n    },\n    ...\n}\n```\n\n新增文件 build/_config.js\n\n```javascript\nlet config = {\n    isDev: false, // 是否为开发环境\n    mode: 'production', // webpack mode：production、development\n    domain: '', // API\n    env: 'pro', // 对应接口：local、pre、pro\n};\n\nmodule.exports = (env, mode) => {\n    config.isDev = mode === 'development';\n    config.mode = mode;\n    config.env = env.CUSTOM_ENV;\n    let domain = '';\n    switch(env.CUSTOM_ENV) {\n        case 'local': // 本地开发环境接口\n            domain = 'local-api.domain.com';\n            break;\n        case 'pre': // 测试环境接口\n            domain = 'pre-api.domain.com';\n            break;\n        default: // 正式环境接口\n            domain = 'api.domain.com';\n    }\n    config.domain = domain;\n    return config;\n};\n```\n\n```javascript\n// 修改webpack.base.js\nconst getConfig = require('./_config');\n\nmodule.exports = (env, mode) => {\n    const envConfig = getConfig(env, mode);\n    return {\n        stats: {\n            children: false, // 清理控制台不必要的打印信息\n        },\n        // 沿用之前的配置\n        entry: { \n            ...\n        },\n        ...\n        plugins: [\n            ...,\n            new webpack.DefinePlugin({ // 自定义全局变量\n                'process.env.CUSTOM_ISDEV': JSON.stringify(envConfig.isDev),\n                'process.env.CUSTOM_MODE': JSON.stringify(envConfig.mode),\n                'process.env.CUSTOM_DOMAIN': JSON.stringify(envConfig.domain),\n                'process.env.CUSTOM_ENV': JSON.stringify(envConfig.env),\n            }),\n        ]\n    }\n}\n```\n\n```javascript\n// 修改webpack.dev.js\nmodule.exports = env => {\n    const mode = 'development';\n    const commonConfig = common(env, mode);\n    return merge(commonConfig, {\n        mode,\n        devtool: 'inline-source-map',\n        ...\n    }\n}\n```\n\n```javascript\n// 修改webpack.prod.js\nmodule.exports = env => {\n    const mode = 'production';\n    const commonConfig = common(env, mode);\n    return merge(commonConfig, {\n        mode,\n        ...\n    }\n}\n```\n\n```javascript\n// src/index.js 新增\nif (process.env.CUSTOM_MODE !== 'production') {\n    console.log('CUSTOM_ISDEV:', process.env.CUSTOM_ISDEV);\n    console.log('CUSTOM_MODE:', process.env.CUSTOM_MODE);\n    console.log('CUSTOM_DOMAIN:', process.env.CUSTOM_DOMAIN);\n    console.log('CUSTOM_ENV:', process.env.CUSTOM_ENV);\n}\n```\n\n> 优化打包信息：通过webpack.base.js中config.stats、命令行中的--progress 优化\n\n##### 2.可视化打包工具测试：webpack-bundle-analyzer\n\n`npm i webpack-bundle-analyzer -D`\n\npackage.json的scripts中增加：\n\n`\"build:stats\": \"webpack --progress --env.CUSTOM_ENV=pro --env.STATS --config build/webpack.prod.js --profile --json > stats.json\"`\n\n修改webpack.prod.js：\n\n```javascript\n...\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\n...\nplugins: [\n    ...,\n    // 分析包大小\n    ...(env.STATS ? [new BundleAnalyzerPlugin()] : [])\n]\n...\n```\n\n使用：`npm run build:stats`生成stats.json文件，再在项目根目录中执行 webpack-bundle-analyzer 后，浏览器会打开对应网页可以看到相关分析结果\n\n##### 3.持久化缓存\n\n`npm i script-ext-html-webpack-plugin -D`\n\n```javascript\n// 修改webpack.dev.js\nconst webpack = require('webpack');\n\nplugins: [\n    ...,\n    new webpack.NamedModulesPlugin(), // 将文件路径作为 id\n]\n```\n\n```javascript\n// 修改webpack.prod.js\n...\nconst webpack = require('webpack');\nconst ScriptExtHtmlWebpackPlugin = require('script-ext-html-webpack-plugin');\nconst seen = new Set();\nconst nameLength = 4;\n\nmodule.exports = env => {\n    ...\n    return merge(commonConfig, {\n        ...\n        optimization: {\n            splitChunks: {\n                chunks: 'all',\n                cacheGroups: {\n                    libs: { // 基础类库:它是构成我们项目必不可少的一些基础类库，比如 vue+vue-router+vuex+axios 这种标准的全家桶，它们的升级频率都不高，但每个页面都需要它们\n                        name: 'chunk-libs',\n                        test: /[\\\\/]node_modules[\\\\/]/,\n                        priority: 10,\n                        chunks: 'initial' // 只打包初始时依赖的第三方\n                    },\n                    antUI: { // UI 组件库\n                        name: 'chunk-ant', // 单独将 ant 拆包\n                        priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app\n                        test: /[\\\\/]node_modules[\\\\/]ant-design-vue[\\\\/]/\n                    },\n                    commons: { // 自定义组件/函数\n                        name: 'chunk-commons',\n                        test: path.resolve(__dirname, '../src/components/components-global'), // 可自定义拓展你的规则，比如注册全局组件的目录\n                        minChunks: 2, // 最小共用次数\n                        priority: 5,\n                        reuseExistingChunk: true\n                    },\n                }\n            },\n            // runtimeChunk：提取 manifest，使用script-ext-html-webpack-plugin等插件内联到index.html减少请求\n            runtimeChunk: true,\n            /*\n            * moduleIds: 固定moduleId；使用文件路径的hash作为 moduleId，解决moduleId递增变化导致的无法长期缓存问题\n            * 相当于在plugins中使用new webpack.HashedModuleIdsPlugin()\n            */\n            moduleIds: 'hashed',\n        },\n        ...,\n        plugins: [\n            ...,\n            // 注意一定要在HtmlWebpackPlugin之后引用, inline 的name 和runtimeChunk 的 name保持一致;将runtime~index.xxx.js内联到html中\n            new ScriptExtHtmlWebpackPlugin({\n                inline: /runtime.*\\.js$/\n            }),\n            // NamedChunkPlugin：结合自定义nameResolver固定chunkId\n            new webpack.NamedChunksPlugin(chunk => {\n                if (chunk.name) {\n                    return chunk.name;\n                }\n                const modules = Array.from(chunk.modulesIterable);\n                if (modules.length > 1) {\n                    const hash = require('hash-sum');\n                    const joinedHash = hash(modules.map(m => m.id).join('_'));\n                    let len = nameLength;\n                    while (seen.has(joinedHash.substr(0, len))) len++;\n                    seen.add(joinedHash.substr(0, len));\n                    return `chunk-${joinedHash.substr(0, len)}`;\n                } else {\n                    return modules[0].id;\n                }\n            })\n        ]\n    });\n}\n\n```\n\n##### 4.生产环境抽取css并压缩优化，同时需要添加js压缩\n\n`npm i mini-css-extract-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin -D`\n\n删除webpack.base.js rules中关于scss和css相关的处理\n\n```javascript\n// 修改webpack.base.js\n...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin'); // 生产环境抽离css\nmodule.exports = (env, mode) => {\n    const envConfig = getConfig(env, mode);\n    const isDev = envConfig.isDev;\n    return {\n        ...,\n        module: {\n            ...,\n            rules: [\n                ...,\n                {\n                    test: /\\.(scss|css)$/,\n                    include: [\n                        path.resolve(__dirname, '../src')\n                    ],\n                    use: [\n                        isDev ? 'style-loader' : {\n                            loader: MiniCssExtractPlugin.loader,\n                            options: {\n                                publicPath: '../' // 让css能成功加载到图片\n                            }\n                        },\n                        'css-loader', 'postcss-loader', 'sass-loader'\n                    ],\n                },\n                {\n                    test: /\\.less$/,\n                    use: [\n                        isDev ? 'style-loader' : {\n                            loader: MiniCssExtractPlugin.loader,\n                            options: {\n                                publicPath: '../'\n                            }\n                        },\n                        'css-loader',\n                        'postcss-loader',\n                        {\n                            loader: 'less-loader',\n                            options: { // ant自定义主题\n                                modifyVars: {\n                                    'primary-color': '#000000',\n                                    'link-color': '#17c9e6',\n                                    'item-hover-bg': '#F7F7F7',\n                                    'item-active-bg': '#f3f3f3',\n                                },\n                                javascriptEnabled: true,\n                            },\n                        }\n                    ],\n                }\n            ]\n        },\n        ...\n    }\n}\n```\n\n```javascript\n// 修改webpack.prod.js\n...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin'); // 抽离css\nconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); // css压缩与优化\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n\n...\noptimization: {\n    ...\n    minimizer: [\n        new UglifyJsPlugin({ // 压缩js\n            cache: true,\n            parallel: true,\n            // sourceMap: true\n        }),\n        new OptimizeCSSAssetsPlugin(), // 压缩css，导致webpack4自带的js压缩无效，需添加UglifyJsPlugin\n    ],\n},\n...\nplugins: [\n    ...\n    // 增加css抽取\n    new MiniCssExtractPlugin({\n        filename: 'css/[name].[contenthash:8].css',\n        // chunkFilename: 'css/[id].[contenthash:8].css'\n    }),\n]\n```\n\n##### 5. 使用DllPlugin、DllReferencePlugin提升编译速度\n\n`npm i add-asset-html-webpack-plugin -D`\n\npackage.json scripts中增加：\n\n```javascript\n\"dll\": \"npm run _dll:pro && npm run _dll:dev\",\n\"_dll:pro\": \"webpack --mode production --progress --config build/webpack.dll.js\",\n\"_dll:dev\": \"webpack --mode development --progress --config build/webpack.dll.js\",\n```\n\n```javascript\n// 新增文件 build/webpack.dll.js\nconst path = require('path');\nconst webpack = require('webpack');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = (env, argv) => {\n    const isDev = argv.mode === 'development';\n    const dir = isDev ? '../dll/dev' : '../dll/pro';\n    return {\n        // mode: 'production', // ???????\n        entry: {\n            // 将数组中的模块作为入口编译成动态链接库\n            'vendor': ['vue', 'vue-router', 'vuex', 'vuex-router-sync', '@ant-design/icons/lib/dist']\n        },\n        output: {\n            // 指定生成文件所在目录\n            // 由于每次打包生产环境时会清空 dist 文件夹，因此这里我将它们存放在了dll文件夹下\n            path: path.resolve(__dirname, dir),\n            // 指定文件名并添加hash\n            filename: '[name].[contenthash:6].dll.js',\n            // 存放动态链接库的全局变量名称，加上 _dll_ 是为了防止全局变量冲突：例如对应 vendor 来说就是 _dll_vendor\n            // 这个名称需要与 DllPlugin 插件中的 name 属性值对应起来\n            library: '_dll_[name]'\n        },\n        plugins: [\n            new CleanWebpackPlugin(),\n            // 接入 DllPlugin\n            new webpack.DllPlugin({\n                // 描述动态链接库的 manifest.json 文件输出时的文件名称\n                path: path.join(__dirname, dir, '[name].manifest.json'),\n                // 动态链接库的全局变量名称，需要和 output.library 中保持一致\n                // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值\n                // 例如 venfor.manifest.json 中就有 \"name\": \"venfor_dll\"\n                name: '_dll_[name]'\n            })\n        ]\n    }\n}\n```\n\n```javascript\n// 修改webpack.base.js\n...\nconst AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');\n\n...\nplugins: [\n    // 告诉 Webpack 使用了哪些动态链接库\n    new webpack.DllReferencePlugin({\n        // 描述 vendor 动态链接库的文件内容\n        manifest: require(isDev ? '../dll/dev/vendor.manifest.json' : '../dll/pro/vendor.manifest.json')\n    }),\n    ...,\n    // 在HtmlWebpackPlugin后使用：用于将vendor插入打包后的页面，并将vendor移动到dist文件夹下面\n    new AddAssetHtmlPlugin([\n        {\n            // 要添加到编译中的文件的绝对路径\n            filepath: path.resolve(__dirname, isDev ? '../dll/dev/vendor.*.dll.js' : '../dll/pro/vendor.*.dll.js'), // 匹配到带hash的文件\n            // 文件输出目录：会在dist文件夹下面再生成dll文件夹\n            outputPath: 'dll',\n            // 脚本或链接标记的公共路径\n            publicPath: 'dll',\n            includeSourcemap: false,\n        }\n    ]),\n]\n```\n\n> 首次使用需要执行`npm run dll`构建出测试/正式环境下的dll文件，html中会自动引入相应的dll文件；以后只要没有修改dll配置，就不需要重新构建dll文件，只有修改了webpack.dll.js，才需要重新执行`npm run dll`。也就是按照上面的描述配置好后，先执行npm run dll，得到dll文件夹下面的文件，之后就可以和之前一样按照npm run dev开发、npm run build打包了\n\n> 这里之所以需要区分环境构建不同dll是因为在mode为production时，devtools无法查看vuex数据，尚未找到其他解决方案\n\n##### 6. 使用happypack多进程加速编译\n\n`npm i happypack -D`\n\n```javascript\n// 修改webpack.base.js\n...\nconst HappyPack = require('happypack');\n// 构造出共享进程池，进程池中包含5个子进程\nconst happyThreadPool = HappyPack.ThreadPool({ size: 5 });\n\nrules: [\n    ...\n    // 修改babel-loader\n    {\n        test: /\\.js$/,\n        use: 'happypack/loader?id=babel',\n        exclude: /node_modules/,\n        include: path.resolve(__dirname, '../src')\n    },\n    {\n        test: /\\.less$/,\n        use: [\n            isDev ? 'style-loader' : {\n                loader: MiniCssExtractPlugin.loader,\n                options: {\n                    publicPath: '../'\n                }\n            },\n            'happypack/loader?id=less'\n        ],\n    }\n],\n...\nplugins: [\n    new HappyPack({\n        // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件\n        id: 'babel',\n        // 如何处理 .js 文件，用法和 Loader 配置中一样\n        loaders: ['babel-loader'],\n        // 使用共享进程池中的子进程去处理任务\n        threadPool: happyThreadPool,\n    }),\n    new HappyPack({\n        id: 'less',\n        loaders: ['css-loader', 'postcss-loader', {\n                loader: 'less-loader',\n                options: { // ant自定义主题\n                    modifyVars: {\n                        'primary-color': '#000000',\n                        'link-color': '#17c9e6',\n                        'item-hover-bg': '#F7F7F7',\n                        'item-active-bg': '#f3f3f3',\n                    },\n                    javascriptEnabled: true,\n                },\n            }\n        ],\n        threadPool: happyThreadPool,\n    }),\n    ...\n]\n```\n\n> tips：这里没有对scss的处理使用happypack，因为使用后发现vue文件中style带scoped会失效，尚未找到原因及解决方案\n\n> 这里使用了happypack之后构建速度反而变慢了，原因？？？\n\n\n##### 7. 其他小调整\n\n```javascript\n// 修改webpack.base.js\n...\nperformance: { // 控制 webpack 如何通知「资源(asset)和入口起点超过指定文件限制」\n    hints: 'warning',\n    maxAssetSize: (isDev ? 20 : 1) * 1024 * 1024, // 单文件：bytes\n    maxEntrypointSize: (isDev ? 20 : 3) * 1024 * 1024, // 入口所有文件：bytes\n},\n...,\nresolve: {\n    ...,\n    modules: [path.resolve(__dirname, '../node_modules')], // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n},\n\n```\n\n> src/index.js中要把`import '@src/plugins';`放到`import '@scss/index.scss';`前面，才不会让ant的样式覆盖了自定义的样式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```javascript\n```\n```javascript\n```\n```javascript\n```\n```javascript\n```\n```javascript\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 学习目录：\n\n<font size=3 color=#63937d>webpack相关:</font>\n* [npm详解](https://juejin.im/post/5ab3f77df265da2392364341)\n* [简单易懂的 webpack 打包后 JS 的运行过程-1](https://juejin.im/post/5a23b130f265da432003101a)\n* [简单易懂的 webpack 打包后 JS 的运行过程-2](https://juejin.im/post/5a34bcf9f265da43070355f8)\n* [import、require、export、module.exports 混合使用详解](https://juejin.im/post/5a2e5f0851882575d42f5609)\n* [webpack 打包机制](https://github.com/happylindz/blog/issues/6)\n* [webpack 应用编译优化之路](https://juejin.im/post/59dc57f2f265da431d3ba2ef)\n* [深入浅出webpack](http://webpack.wuhaolin.cn)\n* [入门Webpack，看这篇就够了](https://www.jianshu.com/p/42e11515c10f)\n* [webpack 优化](https://github.com/happylindz/blog/issues/8)\n* [Webpack4 搭建 Vue 项目](https://juejin.im/post/5b7d350951882542f3278b11)\n* [webpack4.X 实战（二）](https://juejin.im/post/5c74a61bf265da2da00ebae1)\n* [webpack4.X 实战（三）](https://juejin.im/post/5c984983f265da610f7c0ed4)\n* [搭建项目教程](https://juejin.im/post/59097cd7a22b9d0065fb61d2)\n* [使用 Webpack 的 DllPlugin 提升项目构建速度](https://www.jishuwen.com/d/2As1#tuit)\n* [使用webpack4提升180%编译速度](http://louiszhai.github.io/2019/01/04/webpack4/)\n* [移动spa商城优化记（二）--- 减少70%的打包等待时间](https://juejin.im/post/5abf13bf6fb9a028cc61577d)\n* [postcss-loader   autoprefixer](https://blog.csdn.net/qq_37942845/article/details/95047372)\n* [使用 HashedModuleIdsPlugin 解决 hash 频繁变动的问题](https://github.com/sorrycc/roadhog/issues/510)\n* [手摸手，带你用合理的姿势使用webpack4（下）](https://juejin.im/post/5b5d6d6f6fb9a04fea58aabc#heading-4)\n* [css压缩](https://juejin.im/post/5b977a19f265da0ac4469057)\n* [vuex-router-sync](https://blog.csdn.net/jerryman_ghj/article/details/82754209)\n* [ESLint(vue+webpack)配置](https://segmentfault.com/a/1190000016925949)\n* [清理控制台](https://github.com/webpack-contrib/mini-css-extract-plugin/issues/39)\n* [Webpack传参](https://github.com/wayou/wayou.github.io/issues/14)\n\n<font size=3 color=#63937d>遇到的问题:</font>\n* [babel的polyfill和runtime的区别](https://segmentfault.com/q/1010000005596587?from=singlemessage&isappinstalled=1)\n* [Babel学习系列4-polyfill和runtime差别](https://zhuanlan.zhihu.com/p/58624930)\n* [transform-runtime polyfill env](https://www.jianshu.com/p/d078b5f3036a)\n* [关于@babel/polyfill -- 按需加载](https://segmentfault.com/a/1190000018632153)\n* [babel7最佳实践](https://github.com/Weiyu-Chen/blog/issues/5)\n* [Babel 7 升级实践](https://blog.hhking.cn/2019/04/02/babel-v7-update/)\n* [webpack持久化缓存-1](https://github.com/pigcan/blog/issues/9)\n* [webpack持久化缓存-2](https://juejin.im/post/5b977a19f265da0ac4469057)\n\n\n\n以下为本项目构建过程中遇到的疑问查找到的相关参考：\n\n1、什么时候用babel-polyfill，什么时候用babel-runtime？\n\n（1）transform-runtime不会污染全局，但是不能使用实例方法，如Array.find\n\n（2）babel-polyfill会污染全局空间，并可能导致不同版本间的冲突，而babel-runtime不会。从这点看应该用babel-runtime。\n但记住，babel-runtime有个缺点，它不模拟实例方法，即内置对象原型上的方法，所以类似Array.prototype.find，你通过babel-runtime是无法使用的。最后，请不要一次引入全部的polyfills（如require('babel-polyfill')），这会导致代码量很大。请按需引用最好。\n\n（3）按需引入polyfill存在风险，可能无法为某些第三方组件提供其依赖的polyfill:https://juejin.im/post/5cb9833b6fb9a068a84fe4d0,\n\n\n\n遗留问题：\n\n1、依赖包中tree-shaking后的依赖文件能够被编译吗，文件中使用的es6新特性能够被polyfill检测到？\n\n\n\n\n\n"},mxS1:function(n,e){n.exports="# 使用create-react-app完善react移动端框架\n\n> 本笔记主要记录使用create-react-app一步步完善react移动端框架的过程，包括引入react-router、redux、redux、less、antd等。点[项目源码](https://github.com/jiaoyanlin/react_mobile_demo)查看具体细节。\n\n#### 1、项目初始化：\n\n```\nnpm install -g create-react-app // 安装全局命令\n\ncreate-react-app my-app-demo // 创建项目\n\ncd my-app-demo // 进入项目目录\n\nnpm run eject // 放出配置文件，执行后项目目录下多了config和scrips目录\n\nyarn // 安装依赖\n\nyarn start // 启动项目，浏览器会自动打开http://localhost:3000/，项目启动成功\n```\n\n#### 2、引入react router 4：\n\n（1）中文文档：http://reacttraining.cn/web/guides/quick-start\n\n（2）安装依赖\n\n```\nyarn add react-router-dom\n# 或者，不使用 yarn\nnpm install react-router-dom\n```\n\n（3）根据官方示例，在src/App.js粘贴如下代码：\n\n```\nimport React from 'react'\nimport {\n  BrowserRouter as Router,\n  Route,\n  Link\n} from 'react-router-dom'\n\nconst BasicExample = () => (\n  <Router>\n    <div>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li><Link to=\"/about\">About</Link></li>\n        <li><Link to=\"/topics\">Topics</Link></li>\n      </ul>\n\n      <hr/>\n\n      <Route exact path=\"/\" component={Home}/>\n      <Route path=\"/about\" component={About}/>\n      <Route path=\"/topics\" component={Topics}/>\n    </div>\n  </Router>\n)\n\nconst Home = () => (\n  <div>\n    <h2>Home</h2>\n  </div>\n)\n\nconst About = () => (\n  <div>\n    <h2>About</h2>\n  </div>\n)\n\nconst Topics = ({ match }) => (\n  <div>\n    <h2>Topics</h2>\n    <ul>\n      <li>\n        <Link to={`${match.url}/rendering`}>\n          Rendering with React\n        </Link>\n      </li>\n      <li>\n        <Link to={`${match.url}/components`}>\n          Components\n        </Link>\n      </li>\n      <li>\n        <Link to={`${match.url}/props-v-state`}>\n          Props v. State\n        </Link>\n      </li>\n    </ul>\n\n    <Route path={`${match.url}/:topicId`} component={Topic}/>\n    <Route exact path={match.url} render={() => (\n      <h3>Please select a topic.</h3>\n    )}/>\n  </div>\n)\n\nconst Topic = ({ match }) => (\n  <div>\n    <h3>{match.params.topicId}</h3>\n  </div>\n)\n\nexport default BasicExample\n```\n\n（4）此时浏览器中已经可以看到成功引入react-router了\n\n#### 3、引入antd mobile\n\n> 官网提供了为eject前关于create-react-app引入antd-mobile的方案，可以参考[教程](https://mobile.ant.design/docs/react/use-with-create-react-app-cn)进行安装；本项目由于前面已经用npm run eject将配置暴露出来，采用另一种防范安装\n\n（1）安装依赖：\n\n```\ncnpm install babel-plugin-import --save-dev\n\ncnpm install antd-mobile --save\n```\n\n（2）配置按需加载，在config/webpack.config.dev.js中修改如下代码，即在babel-loader中添加plugins：\n\n```\n// Process JS with Babel.\n{\n    test: /\\.(js|jsx|mjs)$/,\n    include: paths.appSrc,\n    loader: require.resolve('babel-loader'),\n    options: {\n        cacheDirectory: true,\n        // 新增代码-----开始\n        plugins: ['transform-runtime', ['import', {\n            libraryName: 'antd-mobile',\n            style: 'css'\n        }]]\n        // 新增代码-----结束\n    },\n},\n```\n同理修改config/webpack.config.prod.js中相关代码\n\n（3）执行`npm start`运行项目，就可以体验antd mobile了，\n\n```\nimport { Button } from 'antd-mobile';\n\n<Button>Start</Button>\n```\n\n\n#### 4、引入路径别名，修改 webpack.config.dev 与 webpack.config.prod 两个文件\n\n```\nfunction resolvePath(dir) {\n    return path.join(__dirname, '..', dir)\n}\n\n// 修改\nalias: {\n    'react-native': 'react-native-web',\n    // 加入以下配置\n    '@': resolvePath('src')\n}\n```\n\n至此以后引入文件可以这么写：`import xxx from '@/yyy/xxx'`\n\n#### 5、引入redux：较复杂，查看代码提交记录\n\n#### 6、引入less：\n\n（1）安装依赖：\n\n```\nnpm install --save-dev less-loader less\n```\n\n（2）修改 webpack.config.dev 与 webpack.config.prod 两个文件\n\n查找 ：`exclude`\n\n原本的 `exclude: [/\\.(js|jsx|mjs)$/, /\\.html$/, /\\.json$/],`\n\n修改为 `exclude: [/\\.html$/, /\\.(js|jsx|mjs)$/, /\\.(css|less)$/, /\\.json$/, /\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],`\n\n\n查找：`test: /.css$/`\n\n原本的 `test: /\\.css$/,`\n\n修改为 `test: /\\.(css|less)$/,`\n\n\n在这个test的下面找到use，添加loader:\n\n```\nuse: [  \n    {...},\n    {...},\n    {\n        loader: require.resolve('less-loader') // compiles Less to CSS\n    }\n],\n```\n\n#### 7、修复打包后的文件直接打开时一片空白：\n\npageage.json 文件增加配置：\"homepage\": \".\",\n\n#### 8、antd mobile定制主题：\n\n（1）首先，你的项目里需要包含如下依赖 babel-plugin-import less less-loader style-loader css-loader\n\n（2）配置 babel-plugin-import 确保加载 antd-mobile less 文件：\n\n```\n{\n    ...\n    \"plugins\": [\n        [\"import\", {\"libraryName\": \"antd-mobile\", \"style\": true}],\n        ...\n    ]\n}\n```\n\n（3）新建文件antMobileTheme.js，用于覆盖ant自带的less变量，[变量表](https://github.com/ant-design/ant-design-mobile/blob/master/components/style/themes/default.less)：\n\n```\nconst theme = {\n    \"brand-primary\": \"yellow\",\n    \"color-text-base\": \"red\",\n    \"fill-base\": '#0b0'\n}\nmodule.exports = theme\n```\n\n（4）修改 webpack.config.dev 与 webpack.config.prod 两个文件\n\n```\nconst theme = require('./antMobileTheme');\n\nmodule.exports = {\n    ...\n    module: {\n        ...\n        rules: [\n            ...\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    // 其实就是修改下面这句为现在这样\n                    { loader: 'less-loader', options: { modifyVars: theme } },\n                ],\n                include: /node_modules/,\n            },\n            ...\n        ],\n    },\n    ...\n}\n\n```\n\n#### 9、移动端适配 rem vw：\n\n（1）参考文章[基于vw等viewport视区单位配合rem响应式排版和布局](http://www.zhangxinxu.com/wordpress/2016/08/vw-viewport-responsive-layout-typography/)，使用vw和rem实现移动端适配，具体就是在引入的主css中加入以下代码：\n\n```\nhtml {\n  \tfont-size: 16px !important;\n}\n\n@media screen and (min-width: 375px) {\n\thtml {\n\t\t/* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */\n\t\tfont-size: calc(100% + 2 * (100vw - 375px) / 39) !important;\n\t\tfont-size: calc(16px + 2 * (100vw - 375px) / 39) !important;\n\t}\n}\n@media screen and (min-width: 414px) {\n\thtml {\n\t\t/* 414px-1000px每100像素宽字体增加1px(18px-22px) */\n\t\tfont-size: calc(112.5% + 4 * (100vw - 414px) / 586) !important;\n\t\tfont-size: calc(18px + 4 * (100vw - 414px) / 586) !important;\n\t}\n}\n@media screen and (min-width: 600px) {\n\thtml {\n\t\t/* 600px-1000px每100像素宽字体增加1px(20px-24px) */\n\t\tfont-size: calc(125% + 4 * (100vw - 600px) / 400) !important;\n\t\tfont-size: calc(20px + 4 * (100vw - 600px) / 400) !important;\n\t}\n}\n@media screen and (min-width: 1000px) {\n\thtml {\n\t\t/* 1000px往后是每100像素0.5px增加 */\n\t\tfont-size: calc(137.5% + 6 * (100vw - 1000px) / 1000) !important;\n\t\tfont-size: calc(22px + 6 * (100vw - 1000px) / 1000) !important;\n\t}\n}\n```\n\n通过以上代码实现：仅用css就可以根据屏幕大小动态改变html根元素的基础字号大小，从而使得页面中使用rem布局的元素实现尺寸的动态变化。\n\n（2）由于ui给出的设计稿是放大过的，比如以iPhone6的375px为基准的设计稿通常宽度时750px，为了后期书写代码的方便，这里使用less将由设计稿量出的px尺寸转换成rem，省去自己计算rem的麻烦：\n\n```\n/*\n* .less文件\n* iPhone6的375px尺寸作为16px基准（即此时1rem对应16px），\n* 而此时设计稿对应的宽为750px，\n* 所以移动端的rem大小 = 设计稿中量出的尺寸/2/16 rem\n*/\n\n.pxtorem(@pro, @px) {\n    @{pro}: (@px / 16 / 2) * 1rem;\n}\n.test1 {\n    .pxtorem(width, 200);\n    .pxtorem(height, 200);\n    .pxtorem(font-size, 32);\n    background: #eee;\n}\n.test2 {\n    width: 100px;\n    height: 100px;\n    font-size: 16px;\n    background: #ddd;\n}\n```\n\n放入实例中可以看到当屏幕为375px时，test1和test2两个元素大小、字号都是一致的，但是test1的大小、字号会随着屏幕变化而变化，而test2不会。\n\n#### 10、使用less解决Retina屏幕1px边框问题：\n\n（1）引入src/assets/less文件夹下的1px.less文件（详见项目文件夹下的源码）；\n\n（2）使用方法：\n\n```\n// .less文件中\n\n@import 'assets/less/1px.less';\n\n.test1 {\n    .pxtorem(width, 200);\n    .pxtorem(height, 200);\n    .pxtorem(font-size, 32);\n    .b-1px(red, 0); // 全边框，参数为（边框颜色，圆角大小）\n    // .b-1px(red, 10px);\n    // .b-1px-t(red); // 上边框，其余还有b-1px-b、b-1px-tb、b-1px-l、b-1px-r\n}\n```\n"},n9MT:function(n,e){n.exports="# React-Native开发：Android真机调试（小米手机miui9系统）\n\n> 建议根据官网给的步骤来进行安装，但是我根据官网步骤安装时遇到了一些报错，因此在这里记录下，[官网步骤：在设备上运行](https://reactnative.cn/docs/0.51/running-on-device-android.html#content)。\n\n### 具体步骤：\n\n1、 开启手机USB调试（在设置->更多设置->开发者选项->USB调试），同时打开USB安装（允许通过USB安装应用，否则初始化app时会安装失败，报INSTALL_FAILED_USER_RESTRICTED错误）；\n\n2、 确保你的设备已经连接成功，在CMD中输入`adb devices`查看当前连接设备，确保只连接了一个设备。（具体参见[官网](https://reactnative.cn/docs/0.51/running-on-device-android.html#content)）\n\n```\n$ adb devices\nList of devices attached\nemulator-5554 offline   # Google模拟器\n14ed2fcc device         # 真实设备\n```\n\n3、在终端进入到react-native目录下运行`react-native run-android`，目的是在设备上安装并启动应用，注意此时手机上会弹出“USB安装提示”，选择继续安装，此时会接着弹出我们的App应用的相关设置，将显示悬浮窗设置为“允许”（否则可能会出现白屏）。\n\n4、 从设备上访问开发服务器：通过“Menu”键或者摇晃设备来打开开发者菜单，点击进入`Dev Settings`，点击`Debug server host for device`，输入你电脑的IP地址和端口号（譬如10.0.1.1:8081），回到开发者菜单然后选择Reload JS。此时应该如果还看不到页面或者报错，尝试关闭该应用并重新打开，应该就能成功连接上App了。\n\n提示：(Android 5.0及以上)可以尝试使用adb reverse命令，运行adb reverse tcp:8081 tcp:8081，不需要更多配置，你就可以使用Reload JS和其它的开发选项了。（官网推荐方式，我还没有尝试）\n\n\n备注：我在执行步骤3时是失败的，可能是当前我手机息屏了，忽略了允许USB安装。后来我通过之前安装的AndroidStudio来运行，虚拟设备中有我的手机，选择该设备并运行，中途记得打开命令行，启动服务器（npm start），然后就成功了。后来我再通过`react-native run-android`命令就能直接安装app进行调试了。\n"},oQGF:function(n,e,t){"use strict";var s=t("vGAL");t.n(s).a},qDsG:function(n,e){n.exports=_dll_highlight},qLOK:function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKoAAACqCAYAAAA9dtSCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkRDMzE1NDc5RTQzOTExRTk4MUY2OTA3RTA0NzkyODc3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkRDMzE1NDdBRTQzOTExRTk4MUY2OTA3RTA0NzkyODc3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6REMzMTU0NzdFNDM5MTFFOTgxRjY5MDdFMDQ3OTI4NzciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6REMzMTU0NzhFNDM5MTFFOTgxRjY5MDdFMDQ3OTI4NzciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6deA+mAAAYOElEQVR42uxdC1hV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"},tjUo:function(n,e,s){"use strict";s.r(e);var t={};s.r(t),s.d(t,"changeMsg",function(){return B});var o={};s.r(o),s.d(o,"mutationsMsg",function(){return V}),s.d(o,"mutationsList",function(){return U});var i={};s.r(i),s.d(i,"gettersMsg",function(){return F});s("Ldmx"),s("8+KV");var r=s("Kw5r"),a=s("FIf5"),l=s.n(a);s("gDt4");r.default.directive("highlight",function(n){n.querySelectorAll("pre code").forEach(function(n){l.a.highlightBlock(n)})});function p(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"list-wrap"},[t.articleKey?s("div",{staticClass:"mark-wrap"},[s("vue-markdown",{directives:[{name:"highlight",rawName:"v-highlight"}],attrs:{source:t.content}})],1):s("div",{staticClass:"article-list"},t._l(t.articleList.list,function(e){return s("div",{key:e.key,staticClass:"article_item",on:{click:function(n){return t.onClickArticle(e.key)}}},[s("h2",{staticClass:"tit"},[t._v(t._s(e.title))]),t._v(" "),s("div",{staticClass:"con"},[t._v(t._s(e.abstract))])])}),0)])}var c=s("jE9Z");p._withStripped=!0;s("HAE/"),s("WLL4"),s("jm62"),s("0l/t"),s("ioFf"),s("rGqo"),s("yt8O"),s("Btvt"),s("RW0V"),s("dRSK");var u=s("rePB"),d=s("L2JU"),m=s("nOak");function g(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,s)}return t}var b={name:"list",components:{VueMarkdown:s.n(m).a},data:function(){return{typeKey:"",articleKey:"",articleList:[]}},computed:function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?g(t,!0).forEach(function(n){Object(u.a)(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):g(t).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}({},Object(d.mapState)({nowRoute:function(n){return n.route},list:function(n){return n.list}}),{content:function(){var n=this.typeKey,e=this.articleKey;return n&&e?s("T+MD")("./".concat(n,"/").concat(e,".md")):""}}),watch:{nowRoute:{immediate:!0,handler:function(n){var e=n.query,t=e.typeKey,s=e.articleKey;if(!t)return this.articleList=this.list[0],this.typeKey=this.list[0].key,!1;this.typeKey!==t&&(this.articleList=this.list.find(function(n){return n.key===t}),this.typeKey=t),this.articleKey=s}}},methods:{onClickArticle:function(n){this.$router.push({name:"list",query:{typeKey:this.typeKey,articleKey:n}})}}},v=(s("u4UV"),s("KHd+")),f=Object(v.a)(b,p,[],!1,null,"31499d3b",null);f.options.__file="src/views/list/index.vue";function h(){var n=this.$createElement;return(this._self._c||n)("div",[this._v("\n    找不到相关页面\n")])}var j=f.exports;h._withStripped=!0;var k={name:"noFound",data:function(){return{}},methods:{}},w=Object(v.a)(k,h,[],!1,null,"d6ba9ed2",null);w.options.__file="src/views/noFound.vue";var x=w.exports;r.default.use(c.default);function y(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{attrs:{id:"app"}},[s("div",{staticClass:"app-main"},[s("div",{staticClass:"app-aside"},[t._m(0),t._v(" "),s("div",{staticClass:"list"},[s("div",{staticClass:"list_tit"},[t._v("文章分类")]),t._v(" "),s("div",{staticClass:"list_con"},t._l(t.list,function(e){return s("div",{key:e.key,class:["list_item",t.typeKey===e.key?"active":""],on:{click:function(n){return t.onClickType(e.key)}}},[t._v("\n                        "+t._s(e.title)+"\n                        "),s("span",{staticClass:"list_num"},[t._v("（"+t._s(e.list.length)+"）")])])}),0)])]),t._v(" "),s("div",{staticClass:"app-content-wrap"},[s("div",{staticClass:"app-content"},[s("router-view")],1)])])])}var A=new c.default({routes:[{path:"/",redirect:"/list"},{path:"/list",name:"list",component:j},{path:"*",name:"noFound",component:x}]}),E=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"my-wrap"},[t("img",{staticClass:"head",attrs:{src:s("O60+"),alt:""}}),n._v(" "),t("div",{staticClass:"text-wrap"},[t("div",[n._v("JiaoyanLin")]),n._v(" "),t("div",{staticClass:"icon-wrap"},[t("a",{staticClass:"icon",attrs:{href:"https://github.com/jiaoyanlin",target:"_blank"}},[t("img",{attrs:{src:s("qLOK"),alt:""}})]),n._v(" "),t("a",{staticClass:"icon",attrs:{href:"https://blog.csdn.net/little_blue_ljy",target:"_blank"}},[t("img",{attrs:{src:s("PAZ5"),alt:""}})])])])])}];y._withStripped=!0;s("f3/d"),s("bWfx"),s("Tze0"),s("pIFo"),s("SRfc");var S=s("Ryk6"),D=S.keys(),P={};D.forEach(function(n){var e=(n.match(/^\.\/([^\/]+)/)||[])[1],t=S(n),s=/# ([^(\n)]+)/,o=(t.match(s)||[])[1],i=t.replace(s,"").trim().replace(/\n/g," ").replace(/(\s)+/g," ").substring(0,120).replace(/(#+ )|(> )/g,"");P[e]||(P[e]=[]),P[e].push({title:o,abstract:i+"...",key:n.match(/.*\/(.+)\.md$/)[1]})});var O=P;function T(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,s)}return t}function C(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?T(t,!0).forEach(function(n){Object(u.a)(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):T(t).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}var N=[{key:"01node",title:"nodejs express mongodb"},{key:"02webpack",title:"webpack npm"},{key:"03vue",title:"vue"},{key:"04react",title:"react react-native"},{key:"05js",title:"js"},{key:"06rollup",title:"rollup"},{key:"07其他",title:"其他"}].map(function(n){return n.list=O[n.key]||[],n}),M={name:"app",data:function(){return{typeKey:""}},computed:C({},Object(d.mapState)({nowRoute:function(n){return n.route},list:function(n){return n.list}})),watch:{nowRoute:{immediate:!0,handler:function(n){if(console.log("------route",n,this.list),"list"===n.name){var e=n.query.typeKey;this.typeKey=e||N[0].key}}}},methods:C({},Object(d.mapMutations)({changeList:"mutationsList"}),{onClickType:function(n){var e=this.nowRoute.query;if(n===e.typeKey&&!e.articleKey)return!1;this.$router.push({name:"list",query:{typeKey:n,articleKey:""}})}}),created:function(){this.changeList(N)}},R=(s("oQGF"),Object(v.a)(M,y,E,!1,null,"2836ff77",null));R.options.__file="src/views/app.vue";var q=R.exports,B=function(n){(0,n.commit)({type:"mutationsMsg",globalMsg:"我是修改后的全局数据~~~"})},V=function(n,e){n.globalMsg=e.globalMsg},U=function(n,e){n.list=e},F=function(n){return n.globalMsg},_={globalMsg:"我是全局数据",list:[]};r.default.use(d.default);var L=new d.default.Store({state:_,getters:i,actions:t,mutations:o}),W=s("Mb3Q");Object(W.sync)(L,A),new r.default({el:"#app",router:A,store:L,render:function(n){return n(q)}})},tjWA:function(n,e){n.exports='# Node.js+Express+MongoDB 建站实例（3）—— 上传图片及其他模块\n\n## 其他模块\n\n由于上两篇文章中已经将如何往数据库中插入、修改数据等做了演示，因此这篇文章就不再重复了，主要记录一些开发时遇到的问题及解决方案（具体实现方法看源码）。\n\n1、 这边推荐使用postman进行接口测试，postman网上有很多教程可以看，主要提一下，在使用postman提交post请求时，注意body中选择x-www-form-urlencoded模式来发送，否则后台这边无法通过req.body.xxx来获取参数。\n\n2、 使用mongodb查询数据库时我们有时会使用_id作为参数进行查询，但是直接将它作为条件是查询不到的，应该按照下方这样来查询：\n\n```javascript\nvar ObjectId = require(\'mongodb\').ObjectId;\n...\n// 更新个人信息\nexports.updateUserinfo = function (req, res, next) {\n    let newData = {\n        "name": req.body.name,\n        "phone": req.body.phone,\n        "motto": req.body.motto\n    };\n    if (!testTel(req.body.phone)) {\n        return res.json({\n            "code": 401,\n            "message": "手机号码格式不正确"\n        })\n    }\n    // 注意这里用ObjectId(req.cookies.id)\n    db.updateMany(\'users\', { "_id": ObjectId(req.cookies.id) }, newData, function (err, result) {\n        if (err) {\n            return res.json({\n                "code": 401,\n                "message": "更新失败"\n            })\n        }\n\n        return res.json({\n            "code": 200,\n            "message": "更新成功"\n        })\n    })\n}\n```\n## 图片上传模块\n\n1、安装依赖 \n    `npm install formidable silly-datetime --save`\n\n2、前端使用ajax的formdata进行上传图片（为了测试也可直接用postman上传，注意body中选择form-data）\n\n```html\n<div>图片上传：<input type="file" name="fileToUpload" id="fileToUpload" class="fileupload" /></div>\n<img style="width: 100px;" />\n```\n\n```javascript\n// 图片上传\n$(\'.fileupload\').change(function(event) {\n    if ($(\'.fileupload\').val().length) {\n        var fileName = $(\'.fileupload\').val();\n        var extension = fileName.substring(fileName.lastIndexOf(\'.\'), fileName.length).toLowerCase();\n        if (extension == ".jpg" || extension == ".png") {\n          var data = new FormData();\n          data.append(\'fulAvatar\', $(\'#fileToUpload\')[0].files[0]);\n          $.ajax({\n              url: \'/api/uploadImg\',\n              type: \'POST\',\n              data: data,\n              cache: false,\n              contentType: false, //不可缺参数\n              processData: false, //不可缺参数\n              success: function(data) {\n                  console.log(\'-------upload img:\', data);\n              },\n              error: function() {\n                  console.log(\'error\');\n              }\n          });\n        }\n    }\n});\n\n```\n\n注意：由于我们再app.js中用了静态服务`app.use(express.static(path.join(__dirname, ‘public’)));`，\n将所有的静态资源文件都托管到public文件夹里。后续操作中如果需要调用public中的图片什么的，\n无论你在哪个文件夹，都把自己当成是在public文件夹即可。\n例如这边可以使用类似`<img style="width: 100px;" src="/avatar/0.2991991519596453.jpg" />`\n来引用public下avatar中的图片\n\n3、后台项目中使用：\n\n```javascript\n// routes/index.js中\n// 上传图片\nrouter.route(\'/api/uploadImg\').all(verifyToken).post(api.uploadImg);\n\n// routes/api.js中\nconst formidable = require(\'formidable\');\nvar sd = require("silly-datetime");\nconst fs = require(\'fs\');\nvar AVATAR_UPLOAD_FOLDER = \'/avatar/\'; // 上传图片存放路径，注意在本项目public文件夹下面新建avatar文件夹\n\n// 上传图片\nexports.uploadImg = function (req, res, next) {\n    var form = new formidable.IncomingForm();   //创建上传表单\n    form.encoding = \'utf-8\';\t\t//设置编辑\n    form.uploadDir = \'public\' + AVATAR_UPLOAD_FOLDER;\t //设置上传目录\n    form.keepExtensions = true;\t //保留后缀\n    form.maxFieldsSize = 2 * 1024 * 1024;   //文件大小\n    \n    form.parse(req, function (err, fields, files) {\n    \n        if (err) {\n            return res.json({\n                "code": 500,\n                "message": "内部服务器错误"\n            })\n        }\n        \n        // 限制文件大小 单位默认字节 这里限制大小为2m\n        if (files.fulAvatar.size > form.maxFieldsSize) {\n            fs.unlink(files.fulAvatar.path)\n            return res.json({\n                "code": 401,\n                "message": "图片应小于2M"\n            })\n        }\n        \n        var extName = \'\';  //后缀名\n        switch (files.fulAvatar.type) {\n            case \'image/pjpeg\':\n                extName = \'jpg\';\n                break;\n            case \'image/jpeg\':\n                extName = \'jpg\';\n                break;\n            case \'image/png\':\n                extName = \'png\';\n                break;\n            case \'image/x-png\':\n                extName = \'png\';\n                break;\n        }\n        \n        if (extName.length == 0) {\n            return res.json({\n                "code": 404,\n                "message": "只支持png和jpg格式图片"\n            })\n        }\n        \n        //使用第三方模块silly-datetime\n        var t = sd.format(new Date(), \'YYYYMMDDHHmmss\');\n        //生成随机数\n        var ran = parseInt(Math.random() * 8999 + 10000);\n        \n        // 生成新图片名称\n        var avatarName = t + \'_\' + ran + \'.\' + extName;\n        // 新图片路径\n        var newPath = form.uploadDir + avatarName;\n        \n        // 更改名字和路径\n        fs.rename(files.fulAvatar.path, newPath, function (err) {\n            if (err) {\n                return res.json({\n                    "code": 401,\n                    "message": "图片上传失败"\n                })\n            }\n            return res.json({\n                "code": 200,\n                "message": "上传成功",\n                result: AVATAR_UPLOAD_FOLDER + avatarName\n            })\n        })\n    });\n\n}\n```\n\n上传文件测试后，可以到上传文件夹public/avatar下查看是否成功\n\n> 源码： [GitHub](https://github.com/jiaoyanlin/myNodeProject)\n\n下一篇文章打算使用react简单构建前端页面，使用这边开发的接口进行开发。\n'},u4UV:function(n,e,t){"use strict";var s=t("uz/1");t.n(s).a},"uz/1":function(n,e,t){},vGAL:function(n,e,t){},yLpj:function(n,e,t){n.exports=t("JG2H")(0)}},[["tjUo","runtime~index","chunk-libs"]]]);